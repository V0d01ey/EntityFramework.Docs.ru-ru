---
title: Устойчивость подключений - EF Core
author: rowanmiller
ms.author: divega
ms.date: 11/15/2016
ms.assetid: e079d4af-c455-4a14-8e15-a8471516d748
ms.technology: entity-framework-core
uid: core/miscellaneous/connection-resiliency
ms.openlocfilehash: aec69577cd4b19fdebedb33ed6fd8f2665b0a032
ms.sourcegitcommit: 860ec5d047342fbc4063a0de881c9861cc1f8813
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2017
ms.locfileid: "26053534"
---
# <a name="connection-resiliency"></a>Устойчивость подключений

Устойчивость подключения автоматически повторяет команды поврежденной базы данных. Компонент может использоваться с любой базой данных, указав «стратегия выполнения», который инкапсулирует логику, необходимую для обнаружения сбоев и повторите команды. EF основные поставщики могут предоставлять точном соответствии с их условия сбоя для заданной базы данных и политики повтора оптимальной стратегии выполнения.

Например поставщик SQL Server включает в себя стратегия выполнения, которая специально предназначено для SQL Server (включая SQL Azure). Он учитывает типов исключений, которые могут быть повторены и имеет допустимых значений по умолчанию для максимального количества повторных попыток, задержка между повторными попытками и т. д.

Стратегия выполнения задается при настройке параметров для текущего контекста. Это обычно находится в `OnConfiguring` метода производного контексте или в `Startup.cs` для приложения ASP.NET Core.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#OnConfiguring)]

## <a name="custom-execution-strategy"></a>Стратегия выполнения пользовательских

Нет механизма регистрации стратегии выполнения пользовательских своим собственным в том случае, если вы хотите изменить любые параметры по умолчанию.

``` csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseMyProvider(
            "<connection string>",
            options => options.ExecutionStrategy(...));
}
```

## <a name="execution-strategies-and-transactions"></a>Стратегиями выполнения и транзакции

Стратегия выполнения, которая автоматически предпринимает попытки восстановления при сбое необходимо воспроизвести каждой операции в блоке повторных попыток, завершаются с ошибкой. После включения повторных попыток, каждой операции, выполняемые через основной EF становится отдельной возможностью повторной попытки операции, т. е. каждый запрос и каждый вызов `SaveChanges()` будет повторена как единое целое, если возникает временная ошибка.

Тем не менее если код инициирует транзакцию, используя `BeginTransaction()` вы определяете собственную группу операций, которые должны рассматриваться как единое целое, т. е. весь код внутри транзакции необходимо воспроизводить должен произойти сбой. При попытке сделать это при использовании стратегия выполнения, будет получено исключение следующим образом.

> Исключение InvalidOperationException: Настроенная стратегия выполнения «SqlServerRetryingExecutionStrategy» не поддерживает транзакции, инициированной пользователем. Используйте возвращенный «DbContext.Database.CreateExecutionStrategy()» стратегии выполнения для выполнения всех операций в транзакции как единое возможностью повторной попытки.

Решением является вызвать стратегия выполнения отражающее все делегатом, который должен выполняться вручную. В случае временного сбоя стратегия выполнения будет снова вызвать делегата.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#ManualTransaction)]

## <a name="transaction-commit-failure-and-the-idempotency-issue"></a>Ошибка фиксации транзакции и о проблеме идемпотентности

В общем случае при сбое подключения текущая транзакция откатывается. Тем не менее, если соединение разорвано во время транзакции выполняется зафиксирована итоговое состояние транзакции неизвестно. См. в этом [блога](http://blogs.msdn.com/b/adonet/archive/2013/03/11/sql-database-connectivity-and-the-idempotency-issue.aspx) для получения дополнительных сведений.

По умолчанию стратегия выполнения будет повторять эту операцию, как в том случае, если откат транзакции, но если это не так это приведет к исключение, если новое состояние базы данных несовместим или может привести к **повреждения данных** Если Операция не полагаться на определенном состоянии, например, при вставке новой строки со значениями ключа, автоматически сгенерированный.

Существует несколько способов решения этой проблемы.

### <a name="option-1---do-almost-nothing"></a>Вариант 1 - выполните nothing (почти)

Вероятность сбоя подключения во время фиксации транзакции не хватает, поэтому он может быть приемлемым для вашего приложения с ошибкой только, если это фактически происходит.

Однако необходимо избегать использования сформированные хранилищем ключи для того чтобы убедиться, что исключение вместо добавления строки с повторяющимися данными. Рекомендуется использовать значение идентификатора GUID, сформированное клиентом или генератор значения на стороне клиента.

### <a name="option-2---rebuild-application-state"></a>Вариант 2 - состояния приложения перестроения

1. Текущая `DbContext`.
2. Создайте новый `DbContext` и восстановить состояние приложения из базы данных.
3. Информировать пользователей, что последняя операция может не была завершена успешно.

### <a name="option-3---add-state-verification"></a>Вариант 3: добавление состояния проверки

Для большинства операций, которые изменяют состояние базы данных можно добавить код, который проверяет, успешно ли оно выполнено. EF предоставляет метод расширения, чтобы облегчить эту задачу - `IExecutionStrategy.ExecuteInTransaction`.

Этот метод начинает и фиксирует транзакцию и также принимает функции в `verifySucceeded` параметр, который вызывается при возникновении временной ошибки во время фиксации транзакции.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Verification)]

> [!NOTE]
> Здесь `SaveChanges` вызывается с `acceptAllChangesOnSuccess` значение `false` во избежание изменения состояния `Blog` сущность `Unchanged` Если `SaveChanges` завершается успешно. Это позволит повторите ту же операцию, если фиксация завершается ошибкой и выполняется откат транзакции.

### <a name="option-4---manually-track-the-transaction"></a>Вариант 4: вручную отслеживать транзакции

Если необходимо использовать сформированные хранилищем ключи или необходим универсальный способ обработки сбоев фиксации, не зависящей от операцию, выполняемую каждой транзакции может назначаться Идентификатором, который проверяется при сбое фиксации.

1. Добавление таблицы к базе данных, используемых для отслеживания состояния транзакций.
2. Вставьте строку в таблицу в начале каждой транзакции.
3. При сбое соединения во время фиксации, проверьте наличие соответствующей строки в базе данных.
4. Если фиксация выполнена успешно, удаление соответствующей строки во избежание увеличение размера таблицы.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Tracking)]

> [!NOTE]
> Убедитесь, что контекст, используемый для проверки стратегия выполнения задаются в качестве соединения может привести к отказу во время проверки сбоя во время фиксации транзакции.

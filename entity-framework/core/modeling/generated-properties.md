---
title: Значения, сформированные - EF Core
author: rowanmiller
ms.author: divega
ms.date: 10/27/2016
ms.assetid: eb082011-11a1-41b4-a108-15daafa03e80
ms.technology: entity-framework-core
uid: core/modeling/generated-properties
ms.openlocfilehash: 88ccc2da3c2b6cbba8920d7113c82e769b459897
ms.sourcegitcommit: 507a40ed050fee957bcf8cf05f6e0ec8a3b1a363
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
ms.locfileid: "31812642"
---
# <a name="generated-values"></a>Формирование значений

## <a name="value-generation-patterns"></a>Шаблоны для создания значения

Существует три шаблона значение поколения, которые можно использовать для свойства.

### <a name="no-value-generation"></a>Без создания значение

Без создания значение означает, что всегда будет указано допустимое значение сохраняется в базе данных. Это допустимое значение должны назначаться новые сущности перед добавлением к контексту.

### <a name="value-generated-on-add"></a>Добавить значение, созданное в

Значение, созданное в надстройка означает генерируется значение для новых сущностей.

В зависимости от используемого поставщика базы данных значения могут быть созданные клиентского по EF или в базе данных. Если это значение формируется базой данных, EF может назначить временное значение при добавлении сущности в контекст. Это временное значение будет выполнена замена по значению создается базой данных во время `SaveChanges()`.

При добавлении сущности в контекст, имеет значение, присваиваемое свойству EF попытается вставить это значение вместо создания нового типа. Свойство видимости, имеет значение, если он не назначается значение по умолчанию для среды CLR (`null` для `string`, `0` для `int`, `Guid.Empty` для `Guid`и т. д.). Дополнительные сведения см. в разделе [явные значения создаваемые свойства](../saving/explicit-values-generated-properties.md).

> [!WARNING]  
> Как это значение формируется для добавленных сущностей будет зависеть от используемого поставщика базы данных. Поставщики базы данных автоматически программой установки для создания значения для некоторых типов свойств, но другим пользователям может потребоваться вручную настроить способ создания значение.
>
> Например, при использовании SQL Server, значения будут создаваться автоматически для `GUID` свойств (с помощью последовательных GUID алгоритм SQL Server). Тем не менее если указать, что `DateTime` свойство создается при добавлении, то необходимо настроить способ создать значения. Является одним из способов сделать это, чтобы настроить значение по умолчанию `GETDATE()`, в разделе [значения по умолчанию](relational/default-values.md).

### <a name="value-generated-on-add-or-update"></a>Значение, созданное на добавление или обновление

Значение, созданное на добавление или обновление означает, что новое значение формируется каждый раз при сохранении записи (insert или update).

Как и `value generated on add`, если задать значение для свойства на вновь добавленный экземпляр сущности, что значение будет вставлено вместо создания значение. Можно также задать явное значение при обновлении. Дополнительные сведения см. в разделе [явные значения создаваемые свойства](../saving/explicit-values-generated-properties.md).

> [!WARNING]
> Как это значение формируется для добавленных и обновленных сущностей будет зависеть от используемого поставщика базы данных. Поставщики базы данных автоматически может установки создания значения для некоторых типов свойств при других будет необходимо вручную настроить способ создания значение.
> 
> Например, при использовании SQL Server `byte[]` свойства, заданные при создании на добавление или обновление и помечен как маркеры параллелизма, будет настроен с `rowversion` тип данных — так, что значения будут создаваться в базе данных. Тем не менее если указать, что `DateTime` свойство создано на добавление или обновление, то необходимо настроить способ создать значения. Является одним из способов сделать это, чтобы настроить значение по умолчанию `GETDATE()` (см. [значения по умолчанию](relational/default-values.md)) для формирования значений для новых строк. Затем триггер базы данных можно использовать для создания значений во время обновления (например, в следующем примере триггер).
> 
> [!code-sql[Main](../../../samples/core/Modeling/FluentAPI/Samples/ValueGeneratedOnAddOrUpdate.sql)]

## <a name="conventions"></a>Соглашения

По соглашению не являющиеся составными первичные ключи типа short, int, long или Guid будет настроен для имеют значения, создаваемые на добавление. Все остальные свойства будет установки с без создания значение.

## <a name="data-annotations"></a>Заметки к данным

### <a name="no-value-generation-data-annotations"></a>Без создания значение (заметок к данным)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Samples/ValueGeneratedNever.cs#Sample)]

### <a name="value-generated-on-add-data-annotations"></a>Значение, созданное в добавить (заметок к данным)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Samples/ValueGeneratedOnAdd.cs#Sample)]

> [!WARNING]  
> Это просто позволяет EF знать, что значения, сформированные для добавленных сущностей, он не гарантирует, что EF настроит реальные механизмы для создания значений. В разделе [добавить значение, созданное в](#value-generated-on-add) более подробные сведения.

### <a name="value-generated-on-add-or-update-data-annotations"></a>Значение, созданное на добавление или обновление (заметок к данным)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Samples/ValueGeneratedOnAddOrUpdate.cs#Sample)]

> [!WARNING]  
> Это просто позволяет EF знать, что значения, сформированные для добавленных или обновленных сущностей, он не гарантирует, что EF настроит реальные механизмы для создания значений. В разделе [значение, созданное в добавлении или обновлении](#value-generated-on-add-or-update) более подробные сведения.

## <a name="fluent-api"></a>Текучий API

Fluent API можно использовать для изменения шаблона поколения значение для заданного свойства.

### <a name="no-value-generation-fluent-api"></a>Без создания значение (Fluent API)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Samples/ValueGeneratedNever.cs#Sample)]

### <a name="value-generated-on-add-fluent-api"></a>Значение, созданное в добавить (Fluent API)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Samples/ValueGeneratedOnAdd.cs#Sample)]

> [!WARNING]  
> `ValueGeneratedOnAdd()` просто позволяет узнать, что значения, сформированные для добавленных сущностей, он не гарантирует, что EF настроит реальные механизмы для создания значений EF.  В разделе [добавить значение, созданное в](#value-generated-on-add) более подробные сведения.

### <a name="value-generated-on-add-or-update-fluent-api"></a>Значение, созданное на добавление или обновление (Fluent API)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Samples/ValueGeneratedOnAddOrUpdate.cs#Sample)]

> [!WARNING]  
> Это просто позволяет EF знать, что значения, сформированные для добавленных или обновленных сущностей, он не гарантирует, что EF настроит реальные механизмы для создания значений. В разделе [значение, созданное в добавлении или обновлении](#value-generated-on-add-or-update) более подробные сведения.

---
title: Необработанные SQL-запросы - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 9e1ee76e-2499-408c-81e8-9b6c5d1945a0
ms.openlocfilehash: 168aee67186535bf2a50705e86bfc5a88147e369
ms.sourcegitcommit: 269c8a1a457a9ad27b4026c22c4b1a76991fb360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2018
ms.locfileid: "46283788"
---
# <a name="raw-sql-queries"></a>Необработанные SQL-запросы
Платформа Entity Framework позволяет выполнять запросы с помощью LINQ с помощью классов сущностей. Тем не менее могут возникнуть ситуации, которые вы хотите выполнять запросы с помощью необработанных SQL непосредственно в базе данных. Это включает в себя вызов хранимых процедур, которые могут оказаться полезными для Code First моделей, которые в настоящее время не поддерживает сопоставление с хранимыми процедурами. Методы, представленные в этом разделе, также применимы к моделям, созданным с помощью Code First и конструктора EF.  

## <a name="writing-sql-queries-for-entities"></a>Написание SQL-запросов для сущностей  

Метод SQL-запрос на DbSet позволяет необработанный SQL-запрос для записи, который возвращает экземпляры сущностей. Возвращаемые объекты будут отслеживаемые по контексту, так же, как было бы, если они были возвращены запросом LINQ. Пример:  

``` csharp  
using (var context = new BloggingContext())
{
    var blogs = context.Blogs.SqlQuery("SELECT * FROM dbo.Blogs").ToList();
}
```  

Обратите внимание, что, так же как и запросы LINQ, запрос не выполняется до перечисляются результаты — в приведенном выше примере это делается с помощью вызова ToList.  

Следует соблюдать осторожность, каждый раз, когда необработанные SQL-запросы записываются по двум причинам. Во-первых запрос должны быть написаны так, чтобы убедиться, что он только возвращает сущности, которые действительно запрошенного типа. Например при использовании механизмы вроде наследования можно легко написать запрос, который будет создание сущностей, которые имеют неправильный тип среды CLR.  

Во-вторых некоторые виды необработанный SQL-запрос предоставлять потенциальные угрозы безопасности, особенно в отношении атаки путем внедрения кода SQL. Убедитесь в том, с использованием параметров в запросе в правильный способ защититься от таких атак.  

### <a name="loading-entities-from-stored-procedures"></a>Загрузка сущностей из хранимых процедур  

DbSet.SqlQuery можно использовать для загрузки сущностей из результатов хранимой процедуры. Например следующий код вызывает dbo. Процедура GetBlogs в базе данных.  

``` csharp
using (var context = new BloggingContext())
{
    var blogs = context.Blogs.SqlQuery("dbo.GetBlogs").ToList();
}
```  

Вы также можете передавать параметры в хранимую процедуру, используя следующий синтаксис:  

``` csharp
using (var context = new BloggingContext())
{
    var blogId = 1;

    var blogs = context.Blogs.SqlQuery("dbo.GetBlogById @p0", blogId).Single();
}
```  

## <a name="writing-sql-queries-for-non-entity-types"></a>Написание SQL-запросов для несущностным типам  

SQL-запроса возвращаются экземпляры любого типа, включая типы-примитивы, могут создаваться с помощью метода SQL-запрос к классу базы данных. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var blogNames = context.Database.SqlQuery<string>(
                       "SELECT Name FROM dbo.Blogs").ToList();
}
```  

Результаты, возвращенные SQL-запрос в базе данных никогда не быть отслеживаемые по контексту, даже если объекты являются экземплярами типа сущности.  

## <a name="sending-raw-commands-to-the-database"></a>Отправка необработанных команды в базу данных  

Команды запросов не могут отправляться в базу данных, используя метод ExecuteSqlCommand в базе данных. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    context.Database.ExecuteSqlCommand(
        "UPDATE dbo.Blogs SET Name = 'Another Name' WHERE BlogId = 1");
}
```  

Обратите внимание, что любые изменения, внесенные в данные в базе данных с помощью ExecuteSqlCommand непрозрачности в контекст пока сущностей не будут загружены или перезагружена из базы данных.  

### <a name="output-parameters"></a>Выходные параметры  

Если используются выходные параметры, их значения не будут доступны, пока не полностью считать результаты. Это происходит из-за особенностей DbDataReader, см. в разделе [получение данных с помощью объекта DataReader](https://go.microsoft.com/fwlink/?LinkID=398589) для получения дополнительных сведений.  

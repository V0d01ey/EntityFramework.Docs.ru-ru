---
title: Конструктора CUD хранимые процедуры — EF6
author: divega
ms.date: 2016-10-23
ms.assetid: 1e773972-2da5-45e0-85a2-3cf3fbcfa5cf
ms.openlocfilehash: 7a3176e1057816dd11ced5fc545aa3baa672bd03
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/27/2018
ms.locfileid: "42993893"
---
# <a name="designer-cud-stored-procedures"></a>Конструктора CUD хранимых процедур
Это пошаговое руководство показано, как сопоставить создания\\вставки, обновления и удаления (CUD) типа сущности с хранимыми процедурами, с помощью Entity Framework Designer (конструктор EF).  По умолчанию Entity Framework автоматически создает инструкции SQL для операций CUD, но также можно сопоставить хранимые процедуры для этих операций.  

Обратите внимание, что Code First не поддерживает сопоставление хранимых процедур или функций. Тем не менее можно вызвать хранимые процедуры или функции с помощью метода System.Data.Entity.DbSet.SqlQuery. Пример:
``` csharp
var query = context.Products.SqlQuery("EXECUTE [dbo].[GetAllProducts]");
```

## <a name="considerations-when-mapping-the-cud-operations-to-stored-procedures"></a>Рекомендации при сопоставлении операций CUD для хранимых процедур

При сопоставлении операций CUD с хранимыми процедурами, следующие соображения. 

-   Если вы осуществляете сопоставление одной из операций CUD в хранимую процедуру, сопоставьте их все. Если не выполнено сопоставление всех трех, то несопоставленные операции завершится ошибкой при выполнении и **UpdateException** будет создано.
-   Свойства сущности необходимо сопоставить каждый параметр хранимой процедуры.
-   Если сервер создает значение первичного ключа для вставленной строки, необходимо сопоставить это значение обратно к свойству ключа сущности. В следующем примере **InsertPerson** хранимая процедура возвращает вновь созданный первичный ключ как часть результирующего набора хранимой процедуры. Первичный ключ сопоставляется с ключом сущности (**PersonID**) с помощью **&lt;Добавление привязок результатов&gt;** функции конструктора Entity FRAMEWORK.
-   Вызовы хранимых процедур, сопоставленных 1:1 с сущностями в концептуальной модели. Например, если вы реализуете иерархии наследования в концептуальной модели и затем карты CUD хранимых процедур для **родительского** (базовый) и **дочерних** (производные) сущности, сохранение **Дочерних** изменений будет вызывать только **дочерних**хранимые процедуры, она не сможет запустить **родительского**хранимые процедуры вызовов.

## <a name="prerequisites"></a>Предварительные требования

Для выполнения данного пошагового руководства требуется:

- Последнюю версию Visual Studio.
- [Образца базы данных School](~/ef6/resources/school-database.md).

## <a name="set-up-the-project"></a>Настройка проекта

-   Откройте Visual Studio 2012.
-   Выберите **файл -&gt; Новинка —&gt; проекта**
-   В левой области щелкните **Visual C\#**, а затем выберите **консоли** шаблона.
-   Введите **CUDSProcsSample** как имя.
-   Нажмите кнопку **ОК**.

## <a name="create-a-model"></a>Создание модели

-   Щелкните правой кнопкой мыши имя проекта в обозревателе решений и выберите **Add -&gt; новый элемент**.
-   Выберите **данных** меню слева, а затем выберите **ADO.NET Entity Data Model** в области шаблонов.
-   Введите **CUDSProcs.edmx** имя файла, а затем нажмите кнопку **добавить**.
-   В диалоговом окне Выбор содержимого модели выберите **создать из базы данных**, а затем нажмите кнопку **Далее**.
-   Нажмите кнопку **новое подключение**. В диалоговом окне Свойства соединения, введите имя сервера (например, **(localdb)\\mssqllocaldb**) выберите метод проверки подлинности, тип **School** для имени базы данных, а затем Нажмите кнопку **ОК**.
    В диалоговом окне Выбор подключения к базе данных обновляется параметр подключения базы данных.
-   В поле выберите ваши объекты базы данных диалогового **таблиц** выберите **Person** таблицы.
-   Кроме того, выберите следующие хранимые процедуры в разделе **хранимые процедуры и функции** узла: **DeletePerson**, **InsertPerson**, и **UpdatePerson** . 
-   Начиная с Visual Studio 2012 конструкторе EF поддерживает массовый импорт хранимых процедур. **Импортировать выбранные хранимые процедуры и функции в модели сущности** установлен по умолчанию. Так как в этом примере мы сохранили процедуры, вставки, обновления и удаления типов сущностей, мы не требуется импортировать их и будет снимите этот флажок. 

    ![ImportSProcs](~/ef6/media/importsprocs.jpg)

-   Нажмите кнопку **Готово**.
    Конструктор EF, который предоставляет область конструктора для изменения модели, отображается.

## <a name="map-the-person-entity-to-stored-procedures"></a>Сопоставление сущности Person с хранимыми процедурами

-   Щелкните правой кнопкой мыши **Person** типа сущности и выберите **сопоставление хранимых процедур**.
-   Сопоставления хранимых процедур, появятся в **сведения о сопоставлении** окна.
-   Нажмите кнопку  **&lt;функция Insert Select&gt;**.
    Поле становится раскрывающимся списком хранимых процедур в модели хранения, которые могут быть сопоставлены с типами сущностей в концептуальной модели.
    Выберите **InsertPerson** из раскрывающегося списка.
-   Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности. Обратите внимание, что стрелки указывают направление сопоставления: «Значения свойств передаются параметрам хранимой процедуры».
-   Нажмите кнопку  **&lt;Добавление привязки к результату&gt;**.
-   Тип **NewPersonID**, имя параметра, возвращенного **InsertPerson** хранимой процедуры. Убедитесь, что не введите начальные или конечные пробелы.
-   Нажмите клавишу **ВВОД**.
-   По умолчанию **NewPersonID** сопоставляется с ключом сущности **PersonID**. Обратите внимание, что стрелка указывает направление сопоставления — значение столбца результата передается свойству.

    ![MappingDetails](~/ef6/media/mappingdetails.png)

-   Нажмите кнопку **&lt;Выбор функции обновления&gt;** и выберите **UpdatePerson** из результирующего раскрывающегося списка.
-   Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.
-   Нажмите кнопку **&lt;Выбор функции удаления&gt;** и выберите **DeletePerson** из результирующего раскрывающегося списка.
-   Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.

Вставки, обновления и удаления операций **Person** типа сущности теперь сопоставлены с хранимыми процедурами.

Если вы хотите включить проверку при обновлении или удалении сущности с хранимыми процедурами параллелизма, используйте один из следующих вариантов:

-   Используйте **ВЫВОДА** параметр для возврата числа обработанных строк из хранимой процедуры и проверка **параметр числа затронутых строк** флажок рядом с именем параметра. Если возвращенное значение равно нулю, при вызове операции [ **OptimisticConcurrencyException** ](https://msdn.microsoft.com/library/system.data.optimisticconcurrencyexception.aspx) будет создано.
-   Проверьте **использовать исходное значение** флажок рядом со свойством, которое вы хотите использовать для проверки параллелизма. При попытке обновления значение свойства, которое было первоначально считано из базы данных будет использоваться при записи данных обратно в базу данных. Если значение не соответствует значению в базе данных, **OptimisticConcurrencyException** будет создано.

## <a name="use-the-model"></a>Использование модели

Откройте **Program.cs** файл, в котором **Main** определен метод. Добавьте следующий код в функцию Main.

Код создает новый **Person** объекта, затем обновляет объект и наконец удаляет объект.         

``` csharp
    using (var context = new SchoolEntities())
    {
        var newInstructor = new Person
        {
            FirstName = "Robyn",
            LastName = "Martin",
            HireDate = DateTime.Now,
            Discriminator = "Instructor"
        }

        // Add the new object to the context.
        context.People.Add(newInstructor);

        Console.WriteLine("Added {0} {1} to the context.",
            newInstructor.FirstName, newInstructor.LastName);

        Console.WriteLine("Before SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // SaveChanges will call the InsertPerson sproc.  
        // The PersonID property will be assigned the value
        // returned by the sproc.
        context.SaveChanges();

        Console.WriteLine("After SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // Modify the object and call SaveChanges.
        // This time, the UpdatePerson will be called.
        newInstructor.FirstName = "Rachel";
        context.SaveChanges();

        // Remove the object from the context and call SaveChanges.
        // The DeletePerson sproc will be called.
        context.People.Remove(newInstructor);
        context.SaveChanges();

        Person deletedInstructor = context.People.
            Where(p => p.PersonID == newInstructor.PersonID).
            FirstOrDefault();

        if (deletedInstructor == null)
            Console.WriteLine("A person with PersonID {0} was deleted.",
                newInstructor.PersonID);
    }
```

-   Скомпилируйте и запустите приложение. Программа создает следующие выходные данные *
    >[!NOTE]
> PersonID формируется автоматически сервером, поэтому вы скорее всего увидите другой номер *

```
Added Robyn Martin to the context.
Before SaveChanges, the PersonID is: 0
After SaveChanges, the PersonID is: 51
A person with PersonID 51 was deleted.
```

Если вы работаете с версией Visual Studio Ultimate, Intellitrace можно использовать с помощью отладчика для просмотра инструкций SQL, которые выполняются.

![IntelliTrace](~/ef6/media/intellitrace.png)

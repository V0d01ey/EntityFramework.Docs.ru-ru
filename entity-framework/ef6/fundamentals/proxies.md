---
title: Работа с прокси - EF6
author: divega
ms.date: 2016-10-23
ms.assetid: 869ee4dc-06f1-471d-8e0e-0a1a2bc59c30
ms.openlocfilehash: 7b82dd370e67d1622fc00ff5e5275721d0fc4fe1
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/27/2018
ms.locfileid: "42997207"
---
# <a name="working-with-proxies"></a>Работа с прокси
При создании экземпляров типов сущностей POCO, Entity Framework часто создает экземпляры динамически создаваемого производный тип, который выступает в качестве прокси для сущности. Этот прокси-сервер переопределяет некоторые виртуальные свойства сущности, которую нужно вставить обработчик для выполнения действий автоматически, при обращении к свойству. Например этот механизм используется для поддержки отложенная загрузка связей. Методы, представленные в этом разделе, также применимы к моделям, созданным с помощью Code First и конструктора EF.  

## <a name="disabling-proxy-creation"></a>Отключение создания прокси-сервера  

Иногда полезно запретить Entity Framework создавать экземпляры прокси-сервера. Например сериализация экземпляров без прокси-сервера — значительно легче, чем сериализации экземпляров прокси-сервера. Создание прокси-сервер можно отключить, сняв флаг ProxyCreationEnabled. Централизованно, это можно сделать это в конструкторе контекста. Пример:  

``` csharp
public class BloggingContext : DbContext
{
    public BloggingContext()
    {
        this.Configuration.ProxyCreationEnabled = false;
    }  

    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }
}
```  

Обратите внимание, что EF не будет создавать учетные записи-посредники для типов там, где нет ничего для прокси-сервера для выполнения. Это означает, что прокси-серверы можно избежать благодаря использованию типов, которые являются запечатанными или нет виртуальных свойств.  

## <a name="explicitly-creating-an-instance-of-a-proxy"></a>Явного создания экземпляра прокси-сервера  

Экземпляр прокси-сервера не создаются при создании экземпляра сущности с помощью оператора new. Это может не быть проблемой, но если вам нужно создать экземпляр прокси-сервера (например, благодаря чему отложенной загрузки или прокси-сервера отслеживания изменений будет работать) затем это можно сделать с помощью метода Create объекта DbSet. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var blog = context.Blogs.Create();
}
```  

Если вы хотите создать экземпляр производного типа сущности используется универсальная версия инструкции Create. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var admin = context.Users.Create<Administrator>();
}
```  

Обратите внимание, что метод Create не добавить или присоединить к контексту созданной сущности.  

Обратите внимание, что метод Create просто создаст экземпляр самого типа сущности при создании прокси-тип сущности будет иметь значение не, поскольку он бы не выполняет никаких действий. Например если тип сущности является запечатанным и/или не имеет виртуальных свойств, а затем создать будет просто создайте экземпляр типа сущности.  

## <a name="getting-the-actual-entity-type-from-a-proxy-type"></a>Получение типа фактические сущности из типа прокси-сервера  

Прокси-типы имеют имена, которые выглядят примерно следующим образом:  

System.Data.Entity.DynamicProxies.Blog_5E43C6C196972BF0754973E48C9C941092D86818CD94005E9A759B70BF6E48E6  

Тип сущности можно найти для этого типа прокси-сервера, с помощью метода GetObjectType от ObjectContext. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var blog = context.Blogs.Find(1);
    var entityType = ObjectContext.GetObjectType(blog.GetType());
}
```  

Обратите внимание, что если тип, передаваемый GetObjectType является экземпляром типа сущности, не является типом прокси-сервера, затем тип сущности, все равно будет возвращена. Это означает, что этот метод всегда можно использовать для получения фактического объекта типа без каких-либо других проверок для просмотра, если тип является типом прокси-сервера, или нет.  

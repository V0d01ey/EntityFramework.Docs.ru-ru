---
title: Обработка сбоев фиксации транзакции - EF6
author: divega
ms.date: 2016-10-23
ms.assetid: 5b1f7a7d-1b24-4645-95ec-5608a31ef577
ms.openlocfilehash: f912777104c2e925122c05046d4d65660de8b8a8
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2018
ms.locfileid: "44250866"
---
# <a name="handling-transaction-commit-failures"></a>Обработка сбоев фиксации транзакции
> [!NOTE]
> **EF6.1 и более поздних версий только** -функции, интерфейсы API, и т.д., описанных на этой странице появились в версии 6.1 Entity Framework. При использовании более ранней версии могут быть неприменимы некоторые или все сведения.  

Как часть 6.1 мы представляем новый функция устойчивости подключений для Entity FRAMEWORK: возможность обнаружить и восстановить автоматически, когда к временному сбою подключения на подтверждения фиксации транзакций. Подробные сведения о сценарий лучше всего описывается в записи блога [подключение к базе данных SQL и проблема идемпотентности](http://blogs.msdn.com/b/adonet/archive/2013/03/11/sql-database-connectivity-and-the-idempotency-issue.aspx).  Таким образом сценарий: при возникновении исключения во время фиксации транзакции существуют две возможные причины:  

1. Не удалось выполнить фиксацию транзакции на сервере
2. Успешность фиксации транзакции на сервере, но проблема с подключением, препятствующих переходу уведомление о выполнении из доставляется клиенту  

Когда происходит первая ситуация или пользователя приложения можно повторить операцию, но когда вторая ситуация происходит следует избегать повторных попыток, и приложение может восстановиться автоматически. Проблема в том, если отсутствует возможность определить, какой параметр имел фактическая причина исключения была обнаружена во время фиксации, приложение не может выбрать правильный способ действий. Новая функция в EF 6.1 позволяет EF еще раз проверьте с базой данных, если транзакция выполнена успешно и прозрачно использовать правильный способ действий.  

## <a name="using-the-feature"></a>С помощью функции  

Чтобы включить функцию требуется включить вызов [SetTransactionHandler](https://msdn.microsoft.com/library/system.data.entity.dbconfiguration.setdefaulttransactionhandler.aspx) в конструкторе вашего **DbConfiguration**. Если вы не знакомы с **DbConfiguration**, см. в разделе [код конфигурации](~/ef6/fundamentals/configuring/code-based.md). Эта функция может использоваться в сочетании с автоматическими повторными попытками, предложенная нами в EF6, которые помогают в ситуации, в котором фактически не удалось зафиксировать транзакцию на сервере из-за временного сбоя:  

``` csharp
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.SqlServer;

public class MyConfiguration : DbConfiguration  
{
  public MyConfiguration()  
  {  
    SetTransactionHandler(SqlProviderServices.ProviderInvariantName, () => new CommitFailureHandler());  
    SetExecutionStrategy(SqlProviderServices.ProviderInvariantName, () => new SqlAzureExecutionStrategy());  
  }  
}
```  

## <a name="how-transactions-are-tracked"></a>Способ отслеживания операций  

Когда эта функция включена, EF автоматически добавит новую таблицу в базе данных с именем **__Transactions**. Новая строка вставляется в этой таблице, каждый раз, транзакция создается с EF и этой строки проверены на существование, если происходит сбой транзакции во время фиксации.  

Несмотря на то, что EF сделает максимум усилий, чтобы очистить строки из таблицы, когда они больше не нужны, таблицы могут увеличиваться, если приложение завершает работу преждевременно и по этой причине, которые могут потребоваться для очистки таблицы вручную в некоторых случаях.  

## <a name="how-to-handle-commit-failures-with-previous-versions"></a>Способ обработки сбоев с предыдущими версиями

Прежде чем EF 6.1 не механизм обработки сбоев в продукте EF. Существует несколько способов работы с этой ситуации, которые могут применяться в предыдущих версиях EF6:  

* Вариант 1: не выполнять никаких действий  

  Вероятность сбоя подключения во время фиксации транзакции недостаточно, поэтому оно может быть приемлемым для вашего приложения, просто ошибкой, если данное состояние возникает, фактически.  

* Вариант 2: использование базы данных для сброса состояния  

  1. Отменить текущее DbContext  
  2. Создать новый DbContext и восстановить состояние приложения из базы данных  
  3. Информировать пользователей о том, что последняя операция не выполнена успешно  

* Вариант 3: вручную отслеживания транзакции  

  1. Добавление таблицы не отслеживаются для базы данных, используемой для отслеживания состояния транзакций.  
  2. Вставьте строку в таблице в начале каждой транзакции.  
  3. В случае сбоя подключения во время фиксации, проверьте наличие соответствующей строки в базе данных.  
     - При наличии строки выполняться как обычно, так как транзакция была успешно зафиксирована  
     - Если строки отсутствует, используйте стратегию выполнения повторить попытку текущей операции.  
  4. Если фиксация выполнена успешно, удалите соответствующей строки во избежание увеличение размера таблицы.  

[В этой записи блога](http://blogs.msdn.com/b/adonet/archive/2013/03/11/sql-database-connectivity-and-the-idempotency-issue.aspx) содержит пример кода для решения этой проблемы на SQL Azure.  

---
title: Пригодность для тестирования и Entity Framework 4.0
author: divega
ms.date: 10/23/2016
ms.assetid: 9430e2ab-261c-4e8e-8545-2ebc52d7a247
ms.openlocfilehash: 0ddf72ab46e2d67dc8a9cf75cbd40430352c5210
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2018
ms.locfileid: "45490536"
---
# <a name="testability-and-entity-framework-40"></a>Пригодность для тестирования и Entity Framework 4.0
Скотт Аллен

Опубликовано: Май 2010 г.

## <a name="introduction"></a>Вступление

В этом техническом документе описывается и демонстрируется способ записи тестируемого кода с помощью ADO.NET Entity Framework 4.0 и Visual Studio 2010. В этом документе не пытается сосредоточиться на конкретных тестирования методологии разработки через тестирование (TDD) или разработки на основе поведения (BDD). Вместо этого в этом документе основное внимание уделяется как написать код, который использует ADO.NET Entity Framework, но остается легко изолировать и проверить в автоматическом режиме. Мы рассмотрим распространенные шаблоны разработки, упростить тестирование в данных сценариях доступа и применение этих шаблонов, при использовании платформы. Мы также рассмотрим особенности платформы framework, чтобы увидеть работу этих возможностей в тестируемого кода.

## <a name="what-is-testable-code"></a>Что такое тестируемого кода?

Возможность проверки компонента с помощью автоматических модульных тестов по предоставляет множество преимуществ нежелательно. Все знают, что хорошие тесты сократит число дефектов программного обеспечения в приложения и увеличение, качество приложения -, однако наличие модульных тестов в месте далеко выходит за рамки, просто обнаружения ошибок.

Набор хороших модульных тестов позволяет группе разработчиков для экономии времени и сохраняете контроль над создаваемое ими программное обеспечение. Команды можно внести изменения существующего кода, рефакторинг и переработки и реструктуризации программного обеспечения к новым требованиям и добавить новые компоненты в приложение при этом знать набор тестов можно проверить поведение приложения. Модульные тесты являются частью цикла быструю обратную связь для упрощения изменений и сохранить удобства обслуживания программного обеспечения, при увеличении сложности.

Модульное тестирование в состав цену, тем не менее. Проектной группе приходится вкладывать время для создания и обслуживания модульных тестов. Трудозатраты, необходимые для создания этих тестов непосредственно связано с **пригодности для тестирования** базового программного обеспечения. Насколько просто программное обеспечение для тестирования? Группы разработки программного обеспечения учитывались возможности тестирования эффективных тестов создается быстрее, чем группа, работающая с нетестируемого программного обеспечения.

Корпорация Microsoft разработала ADO.NET Entity Framework 4.0 (EF4) учитывались возможности тестирования. Это не означает, что разработчики будет записывать модульные тесты для сам код framework. Вместо этого цели тестирования EF4 упрощают создание тестируемого кода, который создает на основе framework. Прежде чем мы рассмотрим конкретные примеры, стоит понять качества кода для тестирования.

### <a name="the-qualities-of-testable-code"></a>Качество тестируемого кода

Код, который легко тестировать всегда будет обладать по крайней мере два признаков. Во-первых, пригодного для тестирования кода легко **наблюдать за**. Учитывая некоторый набор входных данных, должно быть легко наблюдать за результат выполнения кода. Например тестирование следующий метод несложно, так как метод напрямую возвращает результат вычисления.

``` csharp
    public int Add(int x, int y) {
        return x + y;
    }
```

Тестирование метода является сложной задачей, если метод записывает вычисляемое значение в к сетевому сокету, таблицы базы данных или файла аналогично следующему коду. Тест должен выполнить дополнительную работу, чтобы получить значение.

``` csharp
    public void AddAndSaveToFile(int x, int y) {
         var results = string.Format("The answer is {0}", x + y);
         File.WriteAllText("results.txt", results);
    }
```

Во-вторых, тестируемого кода легко **изолировать**. Давайте используем следующий псевдокод неверный пример кода для тестирования.

``` csharp
    public int ComputePolicyValue(InsurancePolicy policy) {
        using (var connection = new SqlConnection("dbConnection"))
        using (var command = new SqlCommand(query, connection)) {

            // business calculations omitted ...               

            if (totalValue > notificationThreshold) {
                var message = new MailMessage();
                message.Subject = "Warning!";
                var client = new SmtpClient();
                client.Send(message);
            }
        }
        return totalValue;
    }
```

Метод легко наблюдать за — мы можно передать в страховой полис и убедитесь, что возвращаемое значение совпадает с ожидаемым результатом. Тем не менее для тестирования метода необходимо установить базу данных с помощью правильную схему и настроить SMTP-сервера в случае, если метод пытается отправить сообщение электронной почты.

Только хочет проверить логику вычислений внутри метода модульного теста, но тест может завершиться ошибкой, поскольку серверу электронной почты находится в автономном режиме, или из-за перемещения сервера базы данных. Оба эти ошибки связаны с поведение, которое желает проверить теста. Поведение трудно локализовать.

Разработчики программного обеспечения, стремиться к созданию кода для тестирования часто стремятся Ведение разделения проблем в коде, что они записывают. Приведенный выше метод необходимо сосредоточиться на бизнес-расчетов и делегировать детали реализации базы данных и адрес электронной почты для других компонентов. Роберт с. Мартин вызывает этот принципа персональной ответственности. Объект следует инкапсулировать один узкий ответственности, скажем, расчет значение политики. Вся остальная работа базы данных и уведомления должно быть ответственность за некоторому другому объекту. Код, написанный таким образом, проще ее изолировать, так как она сосредоточена на одну задачу.

В .NET есть абстракции, нам нужно следовать принципа персональной ответственности и добиться изоляции. Можно использовать интерфейс определения и принудительного кода, чтобы использовать абстракции интерфейс вместо конкретного типа. Далее в этом документе мы рассмотрим, как метод как неправильный приведенного выше примера можно работать с интерфейсы, *выглядеть* , как они будут обмениваться данными к базе данных. Во время тестирования мы может заменить фиктивные реализация, которая не обращаться к базе данных, но вместо этого хранит данные в памяти. Это фиктивная реализация будет изолировать код из несвязанных проблем в модуле кода доступа к данным или базы данных конфигурации.

Существуют дополнительные преимущества изоляции. Бизнес-расчета в последний метод обычно занимает лишь несколько миллисекунд для выполнения, но сам тест могут работать на несколько секунд в качестве кода прыжков в сети и взаимодействует с различными серверами. Модульные тесты должны выполняться fast, чтобы упростить небольшие изменения. Модульные тесты должны также быть повторяемым и не сбоем, так как возникла проблема с компонентом, не имеющих отношения к теста. Создание кода, легко наблюдать и изолировать означает, что разработчики получают это облегчит написание тестов для кода, тратить меньше времени на ожидание исполнение тестов и более важно, тратят меньше времени, ошибок, которые не существуют.

Будем надеяться, что можно оценить преимущества тестирования и понять качеств, которые видно, тестируемого кода. Мы должны решить, как написать код, который работает с помощью EF4 для сохранения данных в базу данных, сохраняя при этом наблюдаемых и легко изолировать, но сначала мы будем сузить основное внимание обсудить тестируемые архитектуры для доступа к данным.

## <a name="design-patterns-for-data-persistence"></a>Шаблоны разработки для постоянного хранения

В обоих примерах неправильный, представленного выше было слишком большого количества обязанностей. Первый пример неправильный пришлось выполнить расчет *и* записи в файл. Во втором примере неправильный требовалось считывать данные из базы данных *и* выполнения расчетов *и* Отправка сообщения электронной почты. Создав небольших методов, которые разделения функций и делегировать ответственность за другими компонентами вносятся большой шаг вперед для написания тестируемого кода. Целью является построение функциональные возможности путем составления действий с небольшим и направленным абстракции.

Когда дело доходит до постоянного хранения небольшую и фокусом абстракции, которые мы ищем настолько распространено, они были задокументированы как шаблоны проектирования. Книги (Martin Fowler) Patterns of Enterprise Application Architecture была первой работой для описания этих шаблонов в печати. Прежде чем мы покажем, как эти платформы ADO.NET Entity Framework реализует и работает с этими шаблонами, мы предоставим краткое описание этих шаблонов в следующих разделах.

### <a name="the-repository-pattern"></a>Шаблон репозитория

Фаулер, — говорит репозиторием «является посредником между доменом и данных уровней сопоставления, с помощью интерфейса обобщенное для доступа к объектам домена». Шаблон репозитория призвано изолировать код из рутинной работе доступа к данным, и как мы видели ранее изоляции является обязательным характерной для тестирования.

Ключом к изоляции является, как хранилище предоставляет объекты, с помощью интерфейса коллекции по принципу. Записи можно использовать хранилище имеет ни малейшего представления как логика репозитории материализуется объекты, которые можно запросить. Хранилище может взаимодействовать с базой данных, или он может просто возвращает объекты из коллекции в памяти. Ваш код должен знать всего лишь репозитории отображается для обслуживания коллекции, что можно получить, добавление и удаление объектов из коллекции.

Конкретный репозиторий в существующих приложений .NET часто наследуется от универсального интерфейса следующим образом:

``` csharp
    public interface IRepository<T> {       
        IEnumerable<T> FindAll();
        IEnumerable<T> FindBy(Expression<Func\<T, bool>> predicate);
        T FindById(int id);
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Сделаем некоторые изменения в определение интерфейса мы предоставлять реализацию для EF4, когда основной принцип остается неизменным. Код с помощью репозиторием конкретные реализации этого интерфейса можно получить сущность по значению первичного ключа, для получения коллекции сущностей, по результатам вычисления предиката, или просто получить все доступные сущности. Код можно также добавлять и удалять сущности через интерфейс репозитория.

Заданных объектов IRepository Employee, код может выполнить следующие операции.

``` csharp
    var employeesNamedScott =
        repository
            .FindBy(e => e.Name == "Scott")
            .OrderBy(e => e.HireDate);
    var firstEmployee = repository.FindById(1);
    var newEmployee = new Employee() {/*... */};
    repository.Add(newEmployee);
```

Поскольку код использует интерфейс (IRepository сотрудника), мы можем предоставить код с помощью различных реализаций интерфейса. Одна реализация может быть реализацию, предлагая EF4 и сохранение объектов в базу данных Microsoft SQL Server. Другую реализацию (один, который используется во время тестирования) может быть подкреплен сотрудника из списка объектов в памяти. Интерфейс поможет добиться изоляции в коде.

Обратите внимание, что IRepository&lt;T&gt; интерфейс не предоставляет операции сохранения. Как обновить существующие объекты? Часто встречаются IRepository определений, которые включают операции сохранения и реализации этих репозиториев необходимо немедленно сохранить объект в базу данных. Тем не менее во многих приложениях мы не хотим сохранять объекты по отдельности. Вместо этого мы хотим вдохните жизнь в объекты, возможно из разных репозиториев, изменить эти объекты как часть бизнес-деятельности и затем сохранить все объекты в рамках одной атомарной операции. К счастью есть шаблон, чтобы разрешить этот тип поведения.

### <a name="the-unit-of-work-pattern"></a>Шаблон единицы работы

Фаулер, — говорит единица работы «сохранит список объектов зависит от бизнес-транзакции и координирует записи изменений и разрешение проблем параллелизма». Это ответственность за единицу работы для отслеживания изменений объектов мы воплотить в жизнь из репозитория и сохранять любые изменения, внесенных в объекты, когда сообщается о единицу работы для фиксации изменений. Это также отвечают за единицу работы для новых объектов, мы добавили ко всем репозиториям и вставить объекты в базе данных, а также управление ими удаления.

Если вы выполняли никакой работы с наборами данных ADO.NET затем вы будете уметь шаблон единицы работы. Наборы данных ADO.NET имел возможность отслеживать наши обновления, удаления и вставки объектов DataRow и удалось (с помощью адаптера таблицы) выверить все изменения в базе данных. Тем не менее объекты DataSet модель отключенных подмножество основной базе данных. Шаблон единицы работы выполняет то же поведение, но работает с бизнес-объекты и объекты домена, которые изолированы от кода доступа к данным и без базы данных.

Абстракция для моделирования единицу работы, в коде .NET может выглядеть следующим образом:

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<Order> Orders { get; }
        IRepository<Customer> Customers { get; }
        void Commit();
    }
```

Предоставляя ссылки репозитория из единицу работы, можно обеспечить единый рабочий объект имеет возможность отслеживать все сущности, материализуется во время бизнес-транзакции. Метод Commit для реальных единицы работы реализуется все Магия для согласования изменений в памяти с базой данных. 

Получает ссылку на IUnitOfWork, код можно внести изменения в бизнес-объекты, полученные из одного или нескольких репозиториев и сохранить все изменения, с помощью атомарные операции фиксации.

``` csharp
    var firstEmployee = unitofWork.Employees.FindById(1);
    var firstCustomer = unitofWork.Customers.FindById(1);
    firstEmployee.Name = "Alex";
    firstCustomer.Name = "Christopher";
    unitofWork.Commit();
```

### <a name="the-lazy-load-pattern"></a>Шаблон отложенной загрузки

Фаулер использует имя отложенной загрузки для описания «объект, который не содержит все данные, вам требуется, но знает, как его получить». Прозрачный отложенная загрузка является важной характеристикой для после написания кода, пригодного для тестирования бизнеса и работа в реляционной базе данных. Например рассмотрим следующий код.

``` csharp
    var employee = repository.FindById(id);
    // ... and later ...
    foreach(var timeCard in employee.TimeCards) {
        // .. manipulate the timeCard
    }
```

Как табелях коллекция заполняется? Существует два возможных варианта ответа. Один ответ – что хранилище сотрудника, в ответ на запрос для получения сотрудника, выдает запрос для получения сотрудника вместе с сотрудника связанные сведения. В реляционных базах данных, это обычно требуется запрос с предложением JOIN и может повлечь за извлечение больше информации, чем приложения должен. Что делать, если приложение никогда не должно touch свойство табелях?

Ответ на второй вопрос — загрузка свойство табелях «по требованию». Эта отложенная загрузка прозрачно для бизнес-логики и неявные потому, что код не вызывает специальные API, чтобы получить сведения. В коде предполагается, что сведения о карте время присутствует, при необходимости. Чудеса с отложенной загрузки, который обычно включает перехват вызовов методов среды выполнения. Перехват кода несет ответственность за обращения к базе данных и получение сведений о времени карты оставив бизнес-логика может быть бизнес-логики. Эти невероятные вещи отложенную загрузку позволяет бизнес-кода для изоляции сам с операциями получения данных и чему больший объем кода, пригодного для тестирования.

Недостатком вызывает отложенную загрузку является, когда приложение *does* необходимые сведения о карте времени, код будет выполняться дополнительный запрос. Это не является проблемой для многих приложений, но для производительности уязвимых приложений или приложений цикла по несколько сотрудников объектов и выполнения запроса для получения карточек времени во время каждой итерации цикла (проблемы часто называют N + 1 задачи с запросами), отложенная загрузка — это перетаскивания. В этих сценариях приложение может потребоваться заблаговременной загрузки сведения в наиболее эффективным способом невозможно.

К счастью мы увидим, как EF4 поддерживает оба неявное отложенной загрузки и эффективный интенсивно загружается информация по мере перемещения в следующем разделе и реализации этих шаблонов.

## <a name="implementing-patterns-with-the-entity-framework"></a>Реализация шаблонов с платформой Entity Framework

Хорошо то, что все шаблоны разработки, описанные в предыдущем разделе, просто реализуется с помощью EF4. Для демонстрации мы собираемся использовать простое приложение ASP.NET MVC для редактирования и отображения сотрудников и их связанные сведения. Мы начнем с помощью следующих «старые объекты CLR» (POCO). 

``` csharp
    public class Employee {
        public int Id { get; set; }
        public string Name { get; set; }
        public DateTime HireDate { get; set; }
        public ICollection<TimeCard> TimeCards { get; set; }
    }

    public class TimeCard {
        public int Id { get; set; }
        public int Hours { get; set; }
        public DateTime EffectiveDate { get; set; }
    }
```

Эти определения классов немного меняется, как мы рассмотрим различные подходы и особенностей EF4, но цель состоит в том, чтобы сохранить эти классы как игнорирующих сохраняемость (PI) максимально. Объект PI не знает *как*, или даже *Если*, состояние, в ней находится внутри базы данных. PI и POCO идут рука об руку с тестируемого программного обеспечения. Объекты, с использованием подхода POCO являются менее ограниченного более гибким и проще тестировать, поскольку они могут работать без базы данных существует.

С помощью POCO на месте мы можем создать Entity Data Model (EDM) в Visual Studio (см. рис. 1). Мы не будем использовать для создания кода для наших сущностей модели EDM. Вместо этого мы хотим использовать сущностей, которые мы любовно создавать вручную. Модель EDM используется только для создания схемы базы данных и введите метаданные EF4 должен сопоставить объекты в базе данных.

![EF test_01](~/ef6/media/eftest-01.jpg)

**Рис. 1**

Примечание: Если вы хотите разрабатывать модель EDM, во-первых, это невозможно создать очистки код POCO из модели EDM. Это можно сделать с помощью расширения Visual Studio 2010, предоставляемые группе программирования данных. Чтобы скачать расширение, запустите диспетчер расширений из меню "Сервис" в Visual Studio и выполните поиск веб-коллекции шаблонов «POCO» (см. рис. 2). Существует несколько шаблонов POCO для Entity FRAMEWORK. Дополнительные сведения об использовании шаблона см. в разделе " [Пошаговое руководство: шаблон POCO для Entity Framework](http://blogs.msdn.com/adonet/pages/walkthrough-poco-template-for-the-entity-framework.aspx)«.

![EF test_02](~/ef6/media/eftest-02.png)

**Рис. 2**

Из этого POCO, начальная точка мы рассмотрим два различных подхода для тестируемого кода. Первый подход, я вызываю метод EF, так как он использует абстракции от Entity Framework API для реализации единицы работы и репозиториев. Второй способ мы создадим собственных абстракций пользовательский репозиторий и затем см. в разделе преимущества и недостатки каждого подхода. Мы начнем с изучения подход EF.  

### <a name="an-ef-centric-implementation"></a>Ориентированные на реализацию EF

Рассмотрим следующее действие контроллера из проекта ASP.NET MVC. Действие извлекает объект Employee и возвращает результат, чтобы отобразить подробное представление сотрудника.

``` csharp
    public ViewResult Details(int id) {
        var employee = _unitOfWork.Employees
                                  .Single(e => e.Id == id);
        return View(employee);
    }
```

Можно протестировать код? Существует по крайней мере два теста, необходимо проверить его поведение. Во-первых мы бы хотели убедиться, что это действие возвращает правильный режим — простым тестом. Мы бы также требуется написать тест, чтобы проверить действие извлекает правильный сотрудника, и мы бы хотели сделать это без выполнения кода в базе данных. Помните, что нам нужно изолировать тестируемый код. Изоляция будет убедитесь, что тест не произошел сбой из-за ошибки в модуле кода доступа к данным или базы данных конфигурации. Если тест не пройден, мы знаем, что у нас есть ошибки в логике контроллера, а не в некоторых нижнего уровня системного компонента.

Для обеспечения изоляции, потребуются некоторые абстракции, как и интерфейсы, которые мы представленные выше для репозиториев и единиц работы. Помните, что шаблон репозитория предназначен в качестве посредника между объектами домена и уровень сопоставления данных. В этом сценарии EF4 *—* слоя сопоставления данных и уже предоставляет абстракцию хранилища с именем помощью IObjectSet&lt;T&gt; (из пространства имен System.Data.Objects). Определение интерфейса выглядит следующим образом.

``` csharp
    public interface IObjectSet<TEntity> :
                     IQueryable<TEntity>,
                     IEnumerable<TEntity>,
                     IQueryable,
                     IEnumerable
                     where TEntity : class
    {
        void AddObject(TEntity entity);
        void Attach(TEntity entity);
        void DeleteObject(TEntity entity);
        void Detach(TEntity entity);
    }
```

Помощью IObjectSet&lt;T&gt; соответствует требованиям для репозитория, так как он напоминает коллекции объектов (через интерфейс IEnumerable&lt;T&gt;) и предоставляет методы для добавления и удаления объектов из коллекции имитации. Методы присоединения и отсоединения предоставляют дополнительные возможности EF4 API. Для использования с помощью IObjectSet&lt;T&gt; как интерфейс для репозиториев, мы должны единицу работы абстракции для связать репозитории вместе.

``` csharp
    public interface IUnitOfWork {
        IObjectSet<Employee> Employees { get; }
        IObjectSet<TimeCard> TimeCards { get; }
        void Commit();
    }
```

Одну конкретную реализацию этого интерфейса будет обращаться к SQL Server и можно легко создать с помощью класса ObjectContext с помощью EF4. Класс ObjectContext является реальной единицей работы в EF4 API.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;
            _context = new ObjectContext(connectionString);
        }

        public IObjectSet<Employee> Employees {
            get { return _context.CreateObjectSet<Employee>(); }
        }

        public IObjectSet<TimeCard> TimeCards {
            get { return _context.CreateObjectSet<TimeCard>(); }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

Перенос с помощью IObjectSet&lt;T&gt; в жизнь так же прост, что и вызов метод CreateObjectSet объекта ObjectContext. За кулисами платформа будет использовать метаданные мы предоставили в модели EDM для создания конкретных ObjectSet&lt;T&gt;. Поместим при возврате помощью IObjectSet&lt;T&gt; интерфейс, так как он поможет сохранить пригодности для тестирования в клиентском коде.

Это конкретная реализация полезно в рабочей среде, но нам нужно сосредоточиться на том, как мы будем использовать наши IUnitOfWork абстракции для упрощения тестирования.

### <a name="the-test-doubles"></a>Тестовых дублеров

Чтобы изолировать действия контроллера нам потребуется возможность переключаться между реальных единицу работы (поддерживаемый ObjectContext) и тест double или «фальшивая» единицы работы (выполнение операций в памяти). Распространенный подход для выполнения такого рода переключение является не могут создать экземпляр единицу работы, но вместо этого передайте единицу работы в качестве параметра конструктора контроллер контроллера MVC.

``` csharp
    class EmployeeController : Controller {
      publicEmployeeController(IUnitOfWork unitOfWork)  {
          _unitOfWork = unitOfWork;
      }
      ...
    }
```

Приведенный выше код является примером внедрения зависимостей. Мы не позволяем на контроллере, чтобы создать его зависимостей (единица работы), но внедрения зависимости в контроллер. В проекте MVC довольно часто использовать фабрику настраиваемый контроллер в сочетании с инверсией управления (IoC) контейнера для автоматизации внедрения зависимостей. Эти темы выходят за рамки данной статьи, но можно прочитать по более следующие ссылки в конце этой статьи.

Единое фиктивные реализации работы, который можно использовать для тестирования может выглядеть следующим образом.

``` csharp
    public class InMemoryUnitOfWork : IUnitOfWork {
        public InMemoryUnitOfWork() {
            Committed = false;
        }
        public IObjectSet<Employee> Employees {
            get;
            set;
        }

        public IObjectSet<TimeCard> TimeCards {
            get;
            set;
        }

        public bool Committed { get; set; }
        public void Commit() {
            Committed = true;
        }
    }
```

Обратите внимание, что фиктивные единицу работы предоставляет свойство были применены. Иногда полезно добавить компоненты в класс фиктивными, упростить тестирование. В этом случае проще наблюдать, если код фиксирует единицу работы, путем проверки свойства были применены.

Нам также потребуется фальшивые помощью IObjectSet&lt;T&gt; для хранения сотрудников и TimeCard объектов в памяти. Мы можем предоставить единую реализацию использовании универсальных шаблонов.

``` csharp
    public class InMemoryObjectSet<T> : IObjectSet<T> where T : class
        public InMemoryObjectSet()
            : this(Enumerable.Empty<T>()) {
        }
        public InMemoryObjectSet(IEnumerable<T> entities) {
            _set = new HashSet<T>();
            foreach (var entity in entities) {
                _set.Add(entity);
            }
            _queryableSet = _set.AsQueryable();
        }
        public void AddObject(T entity) {
            _set.Add(entity);
        }
        public void Attach(T entity) {
            _set.Add(entity);
        }
        public void DeleteObject(T entity) {
            _set.Remove(entity);
        }
        public void Detach(T entity) {
            _set.Remove(entity);
        }
        public Type ElementType {
            get { return _queryableSet.ElementType; }
        }
        public Expression Expression {
            get { return _queryableSet.Expression; }
        }
        public IQueryProvider Provider {
            get { return _queryableSet.Provider; }
        }
        public IEnumerator<T> GetEnumerator() {
            return _set.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        readonly HashSet<T> _set;
        readonly IQueryable<T> _queryableSet;
    }
```

Этот тестовый дублер делегирует большинство операций на базовый класс HashSet&lt;T&gt; объекта. Обратите внимание, помощью IObjectSet&lt;T&gt; требует универсального ограничения применения T в качестве класса (ссылочный тип), а также заставляет нас реализацию IQueryable&lt;T&gt;. Это легко сделать в коллекцию в памяти, которые отображаются как IQueryable&lt;T&gt; с помощью стандартного оператора LINQ AsQueryable.

### <a name="the-tests"></a>Тесты

Традиционные модульные тесты будут использовать одного класса тестов для хранения всех тестов для всех действий в один контроллер MVC. Мы можем написать эти тесты, или любого типа модульного теста, используя в памяти имитаций мы создали. Однако в этой статье, в которой мы будет избегать монолитного приложения тестирования подход на основе класса и сгруппировать связанные наших тестов, чтобы сосредоточиться на определенной части функциональных возможностей.  Например, «создание нового сотрудника» может быть функциональные возможности, которые мы хотим проверить, поэтому мы будем использовать одного класса тестов, чтобы проверить, как одного контроллера работает отвечает за создание нового сотрудника.

Есть некоторые распространенные код настройки, необходимые для все эти детально тестовых классов. Например необходимо всегда создать наших репозиториях в памяти и фальшивые единицу работы. Необходимо также экземпляра контроллера сотрудника с фиктивными единицу работы вставлен. Мы будем совместного использования общего кода установки тестовых классов с помощью базового класса.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .ToList();
            _repository = new InMemoryObjectSet<Employee>(_employeeData);
            _unitOfWork = new InMemoryUnitOfWork();
            _unitOfWork.Employees = _repository;
            _controller = new EmployeeController(_unitOfWork);
        }

        protected IList<Employee> _employeeData;
        protected EmployeeController _controller;
        protected InMemoryObjectSet<Employee> _repository;
        protected InMemoryUnitOfWork _unitOfWork;
    }
```

Мы используем в базовом классе «объект мама» — один из распространенных шаблонов для создания тестовых данных. Мама объект содержит фабричные методы для создания экземпляра сущности теста для использования в нескольких средства тестирования.

``` csharp
    public static class EmployeeObjectMother {
        public static IEnumerable<Employee> CreateEmployees() {
            yield return new Employee() {
                Id = 1, Name = "Scott", HireDate=new DateTime(2002, 1, 1)
            };
            yield return new Employee() {
                Id = 2, Name = "Poonam", HireDate=new DateTime(2001, 1, 1)
            };
            yield return new Employee() {
                Id = 3, Name = "Simon", HireDate=new DateTime(2008, 1, 1)
            };
        }
        // ... more fake data for different scenarios
    }
```

Мы используем EmployeeControllerTestBase как базовый класс для числа средства тестирования (см. рис. 3). Каждый средство тестирования тестирование определенное действие контроллера. Например, одно средство тестирования основное внимание уделяется тестирование создать действие, используемое при выполнении запроса HTTP GET (чтобы отобразить представление для создания сотрудника), и другой тестовый стенд основное внимание уделяется создать действие, используемое в запрос HTTP POST (будет извлекать сведения, отправленные пользователю создать сотрудника). Каждый производный класс отвечает только за настройки, необходимый в его определенном контексте, а также для предоставления утверждения, необходимые для проверки результатов для контекст конкретного теста.

![EF test_03](~/ef6/media/eftest-03.png)

**Рис. 3**

Соглашение о вызовах и тестирования стиль именования представленные здесь, не является обязательным для тестируемого кода — это лишь одним из подходов. Рис. 4 показано, что тесты, выполняемые в Resharper полушарие Jet тестов средство запуска подключаемого модуля для Visual Studio 2010.

![EF test_04](~/ef6/media/eftest-04.png)

**Рис. 4**

С базовым классом для обработки ее кода сетевую установку модульные тесты для каждого действия контроллера небольшим и простым для записи. Тесты будут выполняться быстро (поскольку мы занимаемся операций в памяти) и не должны завершаться сбоем из-за несвязанных инфраструктуры или охраной окружающей среды (поскольку мы определили, что модульного теста).

``` csharp
    [TestClass]
    public class EmployeeControllerCreateActionPostTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldAddNewEmployeeToRepository() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_repository.Contains(_newEmployee));
        }
        [TestMethod]
        public void ShouldCommitUnitOfWork() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_unitOfWork.Committed);
        }
        // ... more tests

        Employee _newEmployee = new Employee() {
            Name = "NEW EMPLOYEE",
            HireDate = new System.DateTime(2010, 1, 1)
        };
    }
```

В этих тестах базовый класс не выполняет большую часть работы программы установки. Помните, что конструктор базового класса создает хранилище в памяти, фиктивный единицу работы и экземпляр класса EmployeeController. Тестовый класс является производным от этого базового класса и фокусируется на особенности тестирование метода Create. В этом случае особенности подразделяются на «упорядочить, действовать и утвердить» шаги, которые можно будет увидеть в любой модульное тестирование процедуры:

-   Создайте объект newEmployee для имитации входящих данных.
-   Вызвать действие Create EmployeeController и передайте newEmployee.
-   Убедитесь, что действие создания получить желаемые результаты, (сотрудника отображается в репозитории).

Мы создали позволяет нам протестировать EmployeeController действия. Например при написании тестов для действии Index контроллера сотрудника мы может наследовать от базового класса теста, чтобы установить эту же базовая установка для наших тестов. Еще раз базовый класс создаст хранилище в памяти, фиктивный единица работы и экземпляр EmployeeController. Тесты для действия индекса только необходимо сосредоточиться на вызове действия индекса и тестирование качества модели действие возвращает.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count);
        }
        [TestMethod]
        public void ShouldOrderModelByHiredateAscending() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                         as IEnumerable<Employee>;
            Assert.IsTrue(model.SequenceEqual(
                           _employeeData.OrderBy(e => e.HireDate)));
        }
        // ...
    }
```

Тесты создаются с помощью fakes в памяти на достижение тестирования *состояние* программного обеспечения. Например при тестировании действия создания, нам нужно проверять состояние репозитория, после выполнения действия создания — репозиторий хранит новый сотрудник?

``` csharp
    [TestMethod]
    public void ShouldAddNewEmployeeToRepository() {
        _controller.Create(_newEmployee);
        Assert.IsTrue(_repository.Contains(_newEmployee));
    }
```

Позже мы рассмотрим взаимодействие на основе тестирования. Тестирование взаимодействия на основе запрашивает Если тестируемый код вызывается соответствующие методы объектов и получает правильные параметры. Сейчас мы перейдем на обложке другой design pattern — отложенной загрузки.

## <a name="eager-loading-and-lazy-loading"></a>Безотложная загрузка и отложенная загрузка

В определенный момент в ASP.NET MVC веб-приложение, которое мы может потребоваться просмотреть информацию сотрудника, а также включать сотрудника связанные время карты. Например может использоваться карта времени отображения сводки, который отображает имя сотрудника и общее количество времени карт в системе. Существует несколько подходов, которые мы можно предпринять для реализации этой возможности.

### <a name="projection"></a>Проекция

— Это один из простых способов создания сводки для построения модели, выделенные с данными, которые нужно отобразить в представлении. В этом случае модель может выглядеть следующим образом.

``` csharp
    public class EmployeeSummaryViewModel {
        public string Name { get; set; }
        public int TotalTimeCards { get; set; }
    }
```

Обратите внимание, что EmployeeSummaryViewModel не является сущностью, — другими словами это не то, что мы должны сохраняться в базе данных. Только мы собираемся использовать этот класс распределяет данные в представление в режиме строгой типизации. Передача данных объекта (DTO), так как в нем нет поведения (методы не) — только свойства аналогична модели представления. Свойства будет содержать данные, необходимые для перемещения. Его можно легко создать экземпляр этой модели представления, с помощью LINQ проекции стандартный оператор — оператор Select.

``` csharp
    public ViewResult Summary(int id) {
        var model = _unitOfWork.Employees
                               .Where(e => e.Id == id)
                               .Select(e => new EmployeeSummaryViewModel
                                  {
                                    Name = e.Name,
                                    TotalTimeCards = e.TimeCards.Count()
                                  })
                               .Single();
        return View(model);
    }
```

Существуют две важные функции в приведенный выше код. Сначала — код можно легко проверить, так как он по-прежнему позволяет легко наблюдать и изолировать. Оператор Select точно так же работает с нашей fakes в памяти, как в случае с реальной единицу работы.

``` csharp
    [TestClass]
    public class EmployeeControllerSummaryActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithCorrectEmployeeSummary() {
            var id = 1;
            var result = _controller.Summary(id);
            var model = result.ViewData.Model as EmployeeSummaryViewModel;
            Assert.IsTrue(model.TotalTimeCards == 3);
        }
        // ...
    }
```

Вторая функция, важные заключается в том, как код позволяет EF4 для формирования запроса единый, эффективных сборка сотрудника и времени сведения о карте друг с другом. Мы загрузили данные о сотрудниках и сведения в тот же объект без использования любые специальные интерфейсы API. Код просто выражен сведения, что он требует использования стандартных операторов LINQ, которые работают с источниками данных в памяти, а также удаленным источникам данных. EF4 была возможность перевода деревья выражений, создаваемый запрос LINQ и C\# компилятора в единый и эффективный запрос T-SQL.

``` SQL
    SELECT
    [Limit1].[Id] AS [Id],
    [Limit1].[Name] AS [Name],
    [Limit1].[C1] AS [C1]
    FROM (SELECT TOP (2)
      [Project1].[Id] AS [Id],
      [Project1].[Name] AS [Name],
      [Project1].[C1] AS [C1]
      FROM (SELECT
        [Extent1].[Id] AS [Id],
        [Extent1].[Name] AS [Name],
        (SELECT COUNT(1) AS [A1]
         FROM [dbo].[TimeCards] AS [Extent2]
         WHERE [Extent1].[Id] =
               [Extent2].[EmployeeTimeCard_TimeCard_Id]) AS [C1]
              FROM [dbo].[Employees] AS [Extent1]
               WHERE [Extent1].[Id] = @p__linq__0
         )  AS [Project1]
    )  AS [Limit1]
```

Существуют в других случаях, когда мы не хотим работать с модели представления или объект DTO, но реальные сущности. Когда мы знаем, нам нужно сотрудник *и* карт время сотрудника, мы можем заранее загрузить связанные данные ненавязчивого и эффективным образом.

### <a name="explicit-eager-loading"></a>Явная Безотложная загрузка

Когда мы хотим заранее загрузить сведения о связанной сущности, необходимо, чтобы какой-либо механизм для бизнес-логики (или в этом случае логика действия контроллера) для выражения необходимость в репозиторий. Для класса ObjectQuery EF4&lt;T&gt; класс определяет метод Include, чтобы задать связанные объекты должны быть получены при запросе. Помните, EF4 ObjectContext предоставляет сущности через конкретный ObjectSet&lt;T&gt; класс, который наследуется от ObjectQuery&lt;T&gt;.  Если мы использовали ObjectSet&lt;T&gt; ссылок в наши действия контроллера, можно было бы написать следующий код, чтобы указать диапазон безотложной загрузки сведения для каждого сотрудника.

``` csharp
    _employees.Include("TimeCards")
              .Where(e => e.HireDate.Year > 2009);
```

Тем не менее, так как мы пытаемся хранить наш код пригодного для тестирования мы не предоставляете ObjectSet&lt;T&gt; из за пределами реальных класс рабочих единиц. Вместо этого мы полагаемся на помощью IObjectSet&lt;T&gt; интерфейс, который гораздо проще подделки, но помощью IObjectSet&lt;T&gt; не определяет метод Include. Красота LINQ — это, можно создать собственный оператор Include.

``` csharp
    public static class QueryableExtensions {
        public static IQueryable<T> Include<T>
                (this IQueryable<T> sequence, string path) {
            var objectQuery = sequence as ObjectQuery<T>;
            if(objectQuery != null)
            {
                return objectQuery.Include(path);
            }
            return sequence;
        }
    }
```

Обратите внимание на то, как метод расширения определен оператор Include для IQueryable&lt;T&gt; вместо помощью IObjectSet&lt;T&gt;. Это дает возможность использовать метод с более широкий диапазон возможных типов, включая IQueryable&lt;T&gt;, помощью IObjectSet&lt;T&gt;, ObjectQuery&lt;T&gt;и ObjectSet&lt;T&gt;. В случае базовой последовательности, не является подлинной ObjectQuery EF4&lt;T&gt;, то нет никакого вреда Готово, и оператор Include является холостой. Если основной последовательности *—* ObjectQuery&lt;T&gt; (или производный от ObjectQuery&lt;T&gt;), то EF4 будет см. в разделе требования дополнительные данные и формулировка правильного SQL запрос.

С помощью этого нового оператора, в месте мы явно запросить диапазон безотложной загрузки сведения из репозитория.

``` csharp
    public ViewResult Index() {
        var model = _unitOfWork.Employees
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

При выполнении для реальных ObjectContext, код создает следующий один запрос. Запрос собирает достаточно информации из базы данных в один обращения к материализации объектов employee и полностью заполнить свойству их труда.

``` SQL
    SELECT
    [Project1].[Id] AS [Id],
    [Project1].[Name] AS [Name],
    [Project1].[HireDate] AS [HireDate],
    [Project1].[C1] AS [C1],
    [Project1].[Id1] AS [Id1],
    [Project1].[Hours] AS [Hours],
    [Project1].[EffectiveDate] AS [EffectiveDate],
    [Project1].[EmployeeTimeCard_TimeCard_Id] AS [EmployeeTimeCard_TimeCard_Id]
    FROM ( SELECT
         [Extent1].[Id] AS [Id],
         [Extent1].[Name] AS [Name],
         [Extent1].[HireDate] AS [HireDate],
         [Extent2].[Id] AS [Id1],
         [Extent2].[Hours] AS [Hours],
         [Extent2].[EffectiveDate] AS [EffectiveDate],
         [Extent2].[EmployeeTimeCard_TimeCard_Id] AS
                    [EmployeeTimeCard_TimeCard_Id],
         CASE WHEN ([Extent2].[Id] IS NULL) THEN CAST(NULL AS int)
         ELSE 1 END AS [C1]
         FROM  [dbo].[Employees] AS [Extent1]
         LEFT OUTER JOIN [dbo].[TimeCards] AS [Extent2] ON [Extent1].[Id] = [Extent2].[EmployeeTimeCard_TimeCard_Id]
    )  AS [Project1]
    ORDER BY [Project1].[HireDate] ASC,
             [Project1].[Id] ASC, [Project1].[C1] ASC
```

Хорошая новость в том, остается полностью тестируемый код внутри метода действия. Не требуется предоставить дополнительные компоненты для наших fakes для поддержки оператор Include. Плохая новость заключается в что нам было необходимо использовать оператор Include внутри кода, мы хотели бы сохранить игнорирующих сохраняемость. Это — отличный пример типа необходимых действиях, которые необходимо оценить при построении тестируемого кода. Бывают случаи, когда необходимо разрешить сохраняемости проблемы утечки за пределами абстракции репозитория в соответствии с целевыми показателями производительности.

Альтернативой Безотложная загрузка является отложенной загрузки. Отложенная загрузка означает, что мы делаем *не* требуется код нашей бизнес явно объявить о требование для связанных данных. Вместо этого мы используем наш сущностей в приложении и ли дополнительные данные, необходимые Entity Framework будет загружать данные по запросу.

### <a name="lazy-loading"></a>Отложенная загрузка

Очень просто Представьте себе ситуацию, где мы не знаем, что потребуется данных часть бизнес-логики. Мы знаем, логика должна объект employee, но мы может выполнять переход в разные пути выполнения которых некоторые из этих путей требуют сведения от сотрудника, а некоторые нет. Такие сценарии, как это идеально подходят для неявного отложенной загрузки, так как данные волшебным образом отображаются по мере необходимости.

Отложенная загрузка, также известный как отложенная загрузка, поместите некоторые требования объектов сущности. Любые требования из уровня сохраняемости не сопряжено с POCO с обеспечением сохраняемости значение true, но true сохраняемости практически невозможно достичь.  Вместо этого мы измеряем сохраняемости в градусах относительный. Было бы нежелательным, если нужно наследовать от базового класса ориентированного сохраняемости или использовать специализированные коллекции для достижения отложенной загрузки в POCO. К счастью EF4 содержит щадящим решения.

### <a name="virtually-undetectable"></a>Практически невозможно обнаружить

При работе с объектами POCO, EF4 может динамически создавать прокси-серверы среды выполнения для сущностей. Эти учетные записи-посредники незаметно wrap материализованные POCO и предоставить дополнительные службы, перехватывая каждого свойства, которые получают операций установки и выполнить дополнительные действия. Из таких служб — это возможность отложенной загрузки, которую мы ищем. Другая служба — это эффективный механизм, который можно записать, когда она изменяет значения свойств сущности отслеживания изменений. Список изменений используется контекст ObjectContext во время выполнения метода SaveChanges для сохранения любого измененных сущностей, с помощью команды обновления.

Для этих учетных записей-посредников для работы Однако они нужен способ обработки свойства get и набора операций на сущности и прокси-серверы достижения этой цели путем переопределения виртуальных членов. Таким образом Если мы хотим использовать неявную отложенную загрузку и эффективное отслеживание изменений необходимо вернуться к нашей определения классов POCO и пометки свойства как виртуальный.

``` csharp
    public class Employee {
        public virtual int Id { get; set; }
        public virtual string Name { get; set; }
        public virtual DateTime HireDate { get; set; }
        public virtual ICollection<TimeCard> TimeCards { get; set; }
    }
```

Мы по-прежнему может сообщать, что сущность сотрудника является главным образом игнорирующих сохраняемость. Единственное требование заключается в том, чтобы использовать виртуальные члены, и это не влияет на пригодность для тестирования кода. Мы не должны наследовать от любого специального базового класса, или даже использовать специальную подборку, выделенных для отложенной загрузки. Как показано в коде, любой класс, реализующий интерфейс ICollection&lt;T&gt; доступен для хранения связанных сущностей.

Имеется также одним небольшим изменением, что необходимо сделать внутри нашей единицей работы. Отложенная загрузка — это *off* по умолчанию при работе непосредственно с объекта ObjectContext. Свойства, которые можно установить для свойства ContextOptions для включения отложенной загрузки, и мы можно установить это свойство внутри наших реальных единица работы, если необходимо, чтобы везде отложенной загрузки.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
         public SqlUnitOfWork() {
             // ...
             _context = new ObjectContext(connectionString);
             _context.ContextOptions.LazyLoadingEnabled = true;
         }    
         // ...
     }
```

Неявные отложенная загрузка включена, код приложения можно использовать сотрудника и сотрудника связанных карт время сохраняя при этом не нужно знать о работы, необходимой для Entity FRAMEWORK загрузить дополнительные данные.

``` csharp
    var employee = _unitOfWork.Employees
                              .Single(e => e.Id == id);
    foreach (var card in employee.TimeCards) {
        // ...
    }
```

Отложенная загрузка упрощает код приложения для записи и с помощью волшебной команды прокси-сервера остается полностью пригодного для тестирования кода. Fakes в памяти, единицы работы просто можно предварительно загрузить фиктивные сущности с связанные данные, при необходимости во время теста.

На этом этапе мы обратим наше внимание от создания репозиториев с помощью помощью IObjectSet&lt;T&gt; и посмотрите на абстракции, чтобы скрыть все знаки платформы сохраняемости.

## <a name="custom-repositories"></a>Пользовательские репозитории

Когда мы впервые представлен шаблон единицы работы конструктора в этой статье мы предоставили пример кода для как может выглядеть единицу работы. Давайте снова представить эту идею исходного, с помощью сотрудников и карта времени ситуацию с сотрудниками, мы работали с.

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<TimeCard> TimeCards { get;  }
        void Commit();
    }
```

— Это основное различие между этой единицы работы и единицу работы, мы создали в предыдущем разделе, как эта единица работы не использовать такие абстракции, с помощью EF4 framework (имеется не помощью IObjectSet&lt;T&gt;). Помощью IObjectSet&lt;T&gt; работает, а также интерфейс репозитория, но он предоставляет API могут быть не согласованы полностью с потребностями приложения. При таком подходе предстоящих будем представлять репозитории, с помощью пользовательских IRepository&lt;T&gt; абстракции.

Многие разработчики, которым следуют разработки через тестирование, проектирование на основе поведения и методологии разработки предметно-ориентированное предпочитают IRepository&lt;T&gt; подход по следующим причинам. Во-первых, IRepository&lt;T&gt; интерфейс представляет слой «защиты от повреждения». Как описано в своей книге проблемно-ориентированное проектирование (Eric Evans) уровень защиты от повреждения хранит код предметной области от инфраструктуры API-интерфейсы, такие как API сохраняемости. Во-вторых разработчики могут создавать методы в репозиторий, отвечают потребностям приложения, (, обнаруженные во время записи тестов). Например мы часто может потребоваться найти одну сущность, с помощью значений Идентификаторов, поэтому мы можем добавить метод FindById интерфейс репозитория.  Наши IRepository&lt;T&gt; определение будет выглядеть следующим образом.

``` csharp
    public interface IRepository<T>
                    where T : class, IEntity {
        IQueryable<T> FindAll();
        IQueryable<T> FindWhere(Expression<Func\<T, bool>> predicate);
        T FindById(int id);       
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Обратите внимание на то, будет отправлено обратно с помощью IQueryable&lt;T&gt; интерфейс для предоставления коллекции сущностей. IQueryable&lt;T&gt; позволяет деревьях выражений LINQ, поступающие в EF4 поставщика и предоставление поставщика целостное представление запроса. Второй вариант будет возвращать объект IEnumerable&lt;T&gt;, это означает, поставщик EF4 LINQ будет видеть только выражения, построенные в репозитории. Любой группирования, сортировки и проекции, вне репозитория будет состоять не в команду SQL, отправленную в базу данных, которая может вызвать снижение производительности. С другой стороны, хранилище, возвращая только IEnumerable&lt;T&gt; результаты будут никогда не удивляет с помощью новой команды SQL. Оба подхода будут работать, и оба подхода остаются пригодного для тестирования.

Это просто для предоставления единую реализацию IRepository&lt;T&gt; интерфейс, с помощью универсальных типов и EF4 ObjectContext API.

``` csharp
    public class SqlRepository<T> : IRepository<T>
                                    where T : class, IEntity {
        public SqlRepository(ObjectContext context) {
            _objectSet = context.CreateObjectSet<T>();
        }
        public IQueryable<T> FindAll() {
            return _objectSet;
        }
        public IQueryable<T> FindWhere(
                               Expression<Func\<T, bool>> predicate) {
            return _objectSet.Where(predicate);
        }
        public T FindById(int id) {
            return _objectSet.Single(o => o.Id == id);
        }
        public void Add(T newEntity) {
            _objectSet.AddObject(newEntity);
        }
        public void Remove(T entity) {
            _objectSet.DeleteObject(entity);
        }
        protected ObjectSet<T> _objectSet;
    }
```

IRepository&lt;T&gt; подход дает нам некоторые дополнительный контроль над наши запросы так, как клиент должен вызвать метод, чтобы перейти к сущности. Внутри метода мы предоставляем дополнительные проверки и операторы LINQ для принудительного применения ограничения для приложения. Обратите внимание, что интерфейс имеет два ограничения для параметра универсального типа. Первое ограничение – недостатки класс нарушить проверку необходимых ObjectSet&lt;T&gt;, и второе ограничение принудительно сущностями для реализации IEntity — это абстракция, созданного для приложения. Интерфейс IEntity заставляет сущностей в удобном для чтения свойств Id, и можно затем использовать это свойство в метод FindById. IEntity определяется следующим кодом.

``` csharp
    public interface IEntity {
        int Id { get; }
    }
```

IEntity можно считать небольшой нарушение сохраняемости, поскольку сущностями необходимы для реализации этого интерфейса. Помните, принцип независимости сохраняемости очень о необходимости поиска компромиссов, и для многих функций FindById перевешивают ограничение, наложенное интерфейс. Интерфейс не оказывает влияния на пригодность для тестирования.

Создание экземпляра динамической IRepository&lt;T&gt; требуется контекст ObjectContext EF4, поэтому конкретные единицы реализации рабочих должен управлять создание экземпляра.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;

            _context = new ObjectContext(connectionString);
            _context.ContextOptions.LazyLoadingEnabled = true;
        }

        public IRepository<Employee> Employees {
            get {
                if (_employees == null) {
                    _employees = new SqlRepository<Employee>(_context);
                }
                return _employees;
            }
        }

        public IRepository<TimeCard> TimeCards {
            get {
                if (_timeCards == null) {
                    _timeCards = new SqlRepository<TimeCard>(_context);
                }
                return _timeCards;
            }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        SqlRepository<Employee> _employees = null;
        SqlRepository<TimeCard> _timeCards = null;
        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

### <a name="using-the-custom-repository"></a>С помощью пользовательского репозитория

С помощью нашего пользовательского репозитория незначительно отличается от использования репозитория, в соответствии с помощью IObjectSet&lt;T&gt;. Вместо применения операторов LINQ непосредственно к свойству, мы сначала необходимо вызвать один методы репозитория, чтобы скопировать IQueryable&lt;T&gt; ссылки.

``` csharp
    public ViewResult Index() {
        var model = _repository.FindAll()
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

Обратите внимание на то, что пользовательский оператор Include, которую мы применили ранее будет работать без изменений. Метод FindById репозитория удаляет повторяющиеся логики из действия, при попытке извлечь одну сущность.

``` csharp
    public ViewResult Details(int id) {
        var model = _repository.FindById(id);
        return View(model);
    }
```

Нет нет существенной разницы в двух подходов, которые мы рассмотрели возможности тестирования. Мы можем решить фиктивных реализаций из IRepository&lt;T&gt; , создав конкретные классы, поддерживаемый HashSet&lt;сотрудника&gt; — так же, как мы сделали в последнем разделе. Тем не менее некоторые разработчики предпочитают использовать макеты объектов и макетирования платформ объекта вместо сборки fakes. Мы рассмотрим использование макетов для тестирования нашей реализации и обсудим различия между макеты и имитаций в следующем разделе.

### <a name="testing-with-mocks"></a>Тестирование с помощью макетов

Существуют различные способы создания какие вызовы (Martin Fowler) «тестовый дублер». Тестовый дублер (например, фильма stunt double) — это объект, создаваемых «вместо» для реальных рабочих объектов во время выполнения тестов. Репозитории в памяти, созданной нами — тестовых дублеров для репозиториев, которые обращаются к SQL Server. Мы узнали, как использовать эти тестовые дублеры во время модульных тестов для изоляции кода и сохранить быстрому запуску тестов.

Тестовых дублеров, которые мы создали имеют реализации реальных, работа. За кулисами каждый из них хранит коллекцию объектов, и они будут добавлять и удалять объекты из данной коллекции, как мы управлять хранилище во время теста. Некоторые разработчики предпочитаю создавать их тестовых дублеров таким образом — с реальный код и работу реализации.  Эти тестовые дублеры так называемые *fakes*. Они имеют рабочей реализации, но они не реальных, для использования в рабочей среде. Имитацией хранилища фактически выполняет запись в базе данных. Фиктивные SMTP-сервера не фактически отправляет сообщение электронной почты по сети.

### <a name="mocks-versus-fakes"></a>Макеты и имитаций

Есть другой тип теста, double, известный как *макетирование*. Хотя fakes рабочий реализаций, макеты поставляются с нет. С помощью платформы макетов объектов создается во время выполнения эти макеты объектов и использовать их в качестве тестовых дублеров. В этом разделе мы будем использовать макетирование framework Moq открытым кодом. Ниже приведен простой пример с помощью Moq для динамического создания теста double для репозиторием сотрудника.

``` csharp
    Mock<IRepository<Employee>> mock =
        new Mock<IRepository<Employee>>();
    IRepository<Employee> repository = mock.Object;
    repository.Add(new Employee());
    var employee = repository.FindById(1);
```

Мы запрашиваем IRepository Moq&lt;сотрудника&gt; реализации и он создает его динамически. Мы можем получить для объекта, реализующего IRepository&lt;сотрудника&gt; путем обращения к свойству объекта фиктивного объекта&lt;T&gt; объекта. Это этот внутренний объект, которые можно передать в наши контроллеры, и он может не знать, если это тестовый дублер или реальные репозитории. Мы можно вызывать методы в объекте, так же, как мы бы вызывать методы на объект с фактической реализации.

Вы должны спросить, что будете выполнять фиктивного репозитория, когда мы вызываем метод Add. Так как не реализацию макета объекта, добавить не выполняет никаких действий. Нет конкретных коллекции за кулисами, как у нас было с помощью fakes, который был записан, чтобы сотрудник удаляется. Как насчет возвращаемое значение FindById? В этом случае макета объекта выполняет единственное, что его можно сделать, это возвращаемое значение по умолчанию. Так как мы возвращается ссылочным типом (сотрудник), возвращается значение null.

Макеты может показаться бесполезным; Тем не менее существуют две дополнительные возможности макетов, которые мы не затрагивали. Во-первых Moq framework записывает все вызовы, выполняемые для макета объекта. Далее в коде мы просим Moq Если любой пользователь вызывается метод Add, или в том случае, если любой пользователь вызывает метод FindById. Мы рассмотрим, как можно использовать эту функцию «черного ящика» запись в тестах.

Второй отличная возможность заключается в том, как можно использовать Moq программировать макет объекта с *ожидания*. Ожидание указывает макета объекта как отвечать на любые данного действия. Например мы программировать ожидание в наш макет и сообщить его, чтобы вернуть объект employee, когда кто-то вызывает FindById. Moq инфраструктура использует API установки и лямбда-выражения программировать эти ожидания.

``` csharp
    [TestMethod]
    public void MockSample() {
        Mock<IRepository<Employee>> mock =
            new Mock<IRepository<Employee>>();
        mock.Setup(m => m.FindById(5))
            .Returns(new Employee {Id = 5});
        IRepository<Employee> repository = mock.Object;
        var employee = repository.FindById(5);
        Assert.IsTrue(employee.Id == 5);
    }
```

В этом примере мы просим Moq динамически создать репозиторий, а затем мы используем при программировании репозиторий с Ожидание. Исходя из предположения о том, макета объекта для возврата объекта сотрудника с идентификатором 5, когда кто-то вызывает метод FindById, передавая значение 5. Этот тест проходит успешно, и нам не нужно создавать полную реализацию, чтобы поддельное IRepository&lt;T&gt;.

Давайте вернемся к тестов, который был записан ранее и переработать их на использование макетов вместо fakes. Так же, как раньше, мы будем использовать базовый класс для настройки общие части инфраструктуры, которые нужны для всех тестов контроллера.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .AsQueryable();
            _repository = new Mock<IRepository<Employee>>();
            _unitOfWork = new Mock<IUnitOfWork>();
            _unitOfWork.Setup(u => u.Employees)
                       .Returns(_repository.Object);
            _controller = new EmployeeController(_unitOfWork.Object);
        }

        protected IQueryable<Employee> _employeeData;
        protected Mock<IUnitOfWork> _unitOfWork;
        protected EmployeeController _controller;
        protected Mock<IRepository<Employee>> _repository;
    }
```

Программный код установки большей части остается неизменным. Вместо использования fakes, мы будем использовать Moq для создания макетов объектов. Базовый класс упорядочивает макетов единицу работы для возврата фиктивного репозитория, когда код вызывает свойство сотрудников. Остальная часть макета настройки будет иметь место внутри средства тестирования, выделенных для каждого конкретного сценария. Например средство тестирования для действия индекса настроим фиктивного репозитория, возвращающий список сотрудников, когда действие вызывает метод FindAll фиктивного репозитория.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        public EmployeeControllerIndexActionTests() {
            _repository.Setup(r => r.FindAll())
                        .Returns(_employeeData);
        }
        // .. tests
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count());
        }
        // .. and more tests
    }
```

За исключением ожиданий наши тесты выглядеть тесты, которые мы использовали ранее. Тем не менее с возможностью записи макетов платформы мы может приблизить тестирования с другого ракурса. Мы рассмотрим это новая Перспектива в следующем разделе.

### <a name="state-versus-interaction-testing"></a>Состояния и тестирование взаимодействия

Существуют различные методы, которые можно использовать для тестирования программного обеспечения макеты объектов. Одним из подходов является использование состояний на основе тестирования, это, что мы проделали в настоящей документации в данный момент. Состояние на основе тестирования делает утверждения о состоянии программного обеспечения. В последней проверки мы вызова метода действия контроллера и утверждение о модели, он должен быть построен. Ниже приведены некоторые другие примеры тестирования состояния.

-   Убедитесь, что хранилище содержит новый объект employee, после выполнения Create.
-   Убедитесь, что модель содержит список всех сотрудников, после выполнения индекса.
-   Убедитесь, что хранилище не содержит данного сотрудника после выполнения удаления.

Другой подход, вы увидите с макеты объектов — для проверки *взаимодействия*. Хотя состояния на основе тестирования делает предположения о состоянии объектов, взаимодействие на основе тестирования делает утверждения о взаимодействии объектов. Пример:

-   Убедитесь, что контроллер вызывает метод Add репозитория при выполнении Create.
-   Убедитесь, что контроллер вызывает метод FindAll репозитория, при выполнении индекса.
-   Убедитесь, что контроллер вызывает единицы работы метода Commit для сохранения изменений, при выполнении редактирования.

Тестирование взаимодействия часто требуется меньше проверочных данных, так как мы не поковыряться внутри коллекции, а также проверка счетчиков. Например если мы знаем, что на действие Details вызывает метод FindById репозитория с правильным значением - нажмите действие, вероятно, работает правильно. Мы можно проверить это без настройки любые тестовые данные для возврата из FindById.

``` csharp
    [TestClass]
    public class EmployeeControllerDetailsActionTests
               : EmployeeControllerTestBase {
         // ...
        [TestMethod]
        public void ShouldInvokeRepositoryToFindEmployee() {
            var result = _controller.Details(_detailsId);
            _repository.Verify(r => r.FindById(_detailsId));
        }
        int _detailsId = 1;
    }
```

Только установки, необходимый в выше средство тестирования состоит в настройке, предоставляемых базовым классом. Когда вызывается действие контроллера, Moq приводит к записи взаимодействия с фиктивного репозитория. С помощью API проверки из Moq, мы можете попросить Moq Если контроллера вызываются FindById с правильным значением идентификатора. Если контроллер не происходит вызов метода, или вызывается метод со значением непредвиденный параметр, проверьте метод вызовет исключение, и тест завершится ошибкой.

Вот еще один пример, чтобы убедиться, что действие создания вызывает фиксации в текущей единице работы.

``` csharp
    [TestMethod]
    public void ShouldCommitUnitOfWork() {
        _controller.Create(_newEmployee);
        _unitOfWork.Verify(u => u.Commit());
    }
```

Один недостаток тестирование взаимодействия является тенденции к через определяют взаимодействие. Способность макета объекта для записи и убедитесь, что любое взаимодействие с макета объекта не значит, тест следует попытаться проверить каждого диалога. Некоторые взаимодействия являются подробностями реализации и необходимо только проверить взаимодействия *требуется* для удовлетворения текущего теста.

Выбор между макеты и имитаций во многом зависит от системы, тестировании и личную (или объединении адаптеров) предпочтения. Макеты объектов может значительно сократить объем кода, необходимо реализовать тестовых дублеров, но не всем удобна, программирование ожиданиям и проверке взаимодействия.

## <a name="conclusions"></a>Выводы

В этом документе мы рассмотрели несколько подходов к созданию кода для тестирования при использовании ADO.NET Entity Framework для постоянного хранения. Можно использовать встроенные абстракций наподобие помощью IObjectSet&lt;T&gt;, или создания собственных абстракций наподобие IRepository&lt;T&gt;.  В обоих случаях поддержка POCO в Entity Framework ADO.NET 4.0 позволяет пользователям эти абстракции сохраняются неведении и широкими возможностями тестирования. Дополнительные возможности EF4 неявную отложенную загрузку позволяет приложению и бизнес-службы, как код работать, не заботясь о деталях реляционного хранилища данных. Наконец эти абстракции, которые будут созданы просты в макетируйте и не Имитируйте внутри модульных тестов, и мы можем использовать эти тестовые дублеры для достижения быстрое выполнение, высокой изолированным и надежные тесты.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   Роберт с. Мартин, " [принцип единственной обязанности](http://www.objectmentor.com/resources/articles/srp.pdf)"
-   (Martin Fowler) [каталог шаблонов](http://www.martinfowler.com/eaaCatalog/index.html) из *шаблоны Enterprise Application Architecture*
-   Caprio Гриффин " [внедрения зависимостей](https://msdn.microsoft.com/magazine/cc163739.aspx)"
-   Блог программистов данных, « [Пошаговое руководство: разработка с помощью Entity Framework 4.0 на основе тестирования](http://blogs.msdn.com/adonet/pages/walkthrough-test-driven-development-with-the-entity-framework-4-0.aspx)«.
-   Блог программистов данных, « [шаблонов с помощью репозитория и единица работы с Entity Framework 4.0](http://blogs.msdn.com/adonet/archive/2009/06/16/using-repository-and-unit-of-work-patterns-with-entity-framework-4-0.aspx)"
-   Дейв Astels, " [введение BDD](http://blog.daveastels.com/files/BDD_Intro.pdf)"
-   Йенсен Аарон " [Общие сведения о спецификации машин](http://codebetter.com/blogs/aaron.jensen/archive/2008/05/08/introducing-machine-specifications-or-mspec-for-short.aspx)"
-   Эрик ли " [BDD с использованием MSTest](http://blogs.msdn.com/elee/archive/2009/01/20/bdd-with-mstest.aspx)"
-   (Eric Evans), " [предметно-ориентированное проектирование](http://books.google.com/books?id=7dlaMs0SECsC&printsec=frontcover&dq=evans%20domain%20driven%20design&hl=en&ei=cHztS6C8KIaglAfA_dS1CA&sa=X&oi=book_result&ct=result&resnum=1&ved=0CCoQ6AEwAA)"
-   (Martin Fowler) « [макетов не только заглушки](http://martinfowler.com/articles/mocksArentStubs.html)"
-   (Martin Fowler) « [тестирования двойной](http://martinfowler.com/bliki/TestDouble.html)"
-   Джереми Миллер " [состояние и тестирование взаимодействия](http://codebetter.com/blogs/jeremy.miller/articles/129544.aspx)"
-   [MOQ](http://code.google.com/p/moq/)

### <a name="biography"></a>Биография

Скотт Аллен является членом технического персонала в Pluralsight и учредитель OdeToCode.com. В 15-летним коммерческой разработки программных продуктов Скотт участвовал в решения для всех операций из 8-разрядных устройств embedded позволяет высокомасштабируемых веб-приложений ASP.NET. Скоттом можно связаться на его блог по адресу OdeToCode или в Твиттере [ http://twitter.com/OdeToCode ](http://twitter.com/OdeToCode).

---
title: Перенос приложений из EF6 в EF Core — Проверка требований
author: rowanmiller
ms.author: divega
ms.date: 10/27/2016
ms.assetid: d3b66f3c-9d10-4974-a090-8ad093c9a53d
uid: efcore-and-ef6/porting/ensure-requirements
ms.openlocfilehash: 65bdc8bb9574d37db697aa47c8e8c480cefcb4f7
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/10/2018
ms.locfileid: "37949118"
---
# <a name="before-porting-from-ef6-to-ef-core-validate-your-applications-requirements"></a>Прежде чем перенос приложений из EF6 в EF Core: проверка требования вашего приложения

Перед началом процесса переноса важно проверить EF Core, соответствует ли требований доступа к данным для вашего приложения.

## <a name="missing-features"></a>Для отсутствующих компонентов

Убедитесь, что EF Core имеет все функции, которые необходимо использовать в приложении. См. в разделе [сравнение функций](../features.md) подробное сравнение сравнение с набором функций из EF Core с EF6. Если все необходимые компоненты отсутствуют, убедитесь, что вы можете компенсировать отсутствие этих функций перед развертыванием в EF Core.

## <a name="behavior-changes"></a>Изменения в поведении

Это неполный список некоторые изменения в поведении между EF6 и EF Core. Важно помнить как порт приложения, так как они могут изменить способ приложение ведет себя, но не будут отображаться как ошибки компиляции после переключения в EF Core.

### <a name="dbsetaddattach-and-graph-behavior"></a>Поведение DbSet.Add/Attach и graph

В EF6 вызвав `DbSet.Add()` на результаты сущностей в рекурсивный поиск для всех сущностей, на которые ссылается его свойства навигации. Все сущности, на которые имеются и, не отслеживаются контекстом, можно пометить как добавлен. `DbSet.Attach()` работает так же, за исключением того, все сущности, помечаются как без изменений.

**EF Core выполняет рекурсивный поиск аналогичный, но в некоторых правил немного отличается.**

*  Корневая сущность всегда указывается в запрошенное состояние (для `DbSet.Add` и не изменяется для `DbSet.Attach`).

*  **Для сущностей, которые были обнаружены во время рекурсивный поиск свойств навигации:**

    *  **Если первичный ключ сущности сохраняются созданные**

        * Если первичный ключ не присвоено значение, состояние устанавливается на добавлена. Значение первичного ключа считается «не установлено» назначена CLR по умолчанию для типа свойства (например, `0` для `int`, `null` для `string`и т. д.).

        * Если первичный ключ, присваивается значение, состояние имеет значение без изменений.

    *  Если первичный ключ не сформированный базой данных, сущность помещается в том же состоянии, в качестве привилегированного пользователя.

### <a name="code-first-database-initialization"></a>Код инициализации первой базы данных

**EF6 имеет значительный объем magic, выполняемых по выбору подключения к базе данных и инициализации базы данных. Ниже перечислены некоторые из этих правил.**

* Если конфигурация не выполняется, EF6 выберет базу данных в SQL Express или LocalDb.

* Если строка подключения с тем же именем, как контекст — в приложениях `App/Web.config` файл, будет использоваться это соединение.

* Если базы данных не существует, он создается.

* Если ни одной из таблиц из модели существует в базе данных, схема для текущей модели добавляется в базу данных. Если включены миграций, они используются для создания базы данных.

* Если база данных существует и EF6 ранее создали схемы, схемы проверяется на совместимость с текущей моделью. Исключение возникает в том случае, если модель данных была изменена с момента создания схемы.

**EF Core не выполняет эти невероятные вещи.**

* Подключение к базе данных должна быть настроена явным образом в коде.

* Инициализация не выполняется. Необходимо использовать `DbContext.Database.Migrate()` по применению миграции (или `DbContext.Database.EnsureCreated()` и `EnsureDeleted()` для создания и удаления базы данных без использования миграции).

### <a name="code-first-table-naming-convention"></a>Код первой таблицы, соглашение об именовании

EF6 выполняется с именем класса сущностей через службу преобразования во множественную форму, для которого требуется вычислить имя таблицы по умолчанию, который сопоставляется сущность.

EF Core использует имя `DbSet` свойства, предоставляемого сущность в производном контексте. Если сущность не содержит `DbSet` используется свойство, а затем имя класса.
